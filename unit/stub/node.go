// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery
// template: testify

package stub

import (
	"time"

	"ergo.services/ergo/gen"
	mock "github.com/stretchr/testify/mock"
)

// NewNode creates a new instance of Node. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewNode(t interface {
	mock.TestingT
	Cleanup(func())
}) *Node {
	mock := &Node{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// Node is an autogenerated mock type for the Node type
type Node struct {
	mock.Mock
}

type Node_Expecter struct {
	mock *mock.Mock
}

func (_m *Node) EXPECT() *Node_Expecter {
	return &Node_Expecter{mock: &_m.Mock}
}

// ApplicationInfo provides a mock function for the type Node
func (_mock *Node) ApplicationInfo(name gen.Atom) (gen.ApplicationInfo, error) {
	ret := _mock.Called(name)

	if len(ret) == 0 {
		panic("no return value specified for ApplicationInfo")
	}

	var r0 gen.ApplicationInfo
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(gen.Atom) (gen.ApplicationInfo, error)); ok {
		return returnFunc(name)
	}
	if returnFunc, ok := ret.Get(0).(func(gen.Atom) gen.ApplicationInfo); ok {
		r0 = returnFunc(name)
	} else {
		r0 = ret.Get(0).(gen.ApplicationInfo)
	}
	if returnFunc, ok := ret.Get(1).(func(gen.Atom) error); ok {
		r1 = returnFunc(name)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Node_ApplicationInfo_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ApplicationInfo'
type Node_ApplicationInfo_Call struct {
	*mock.Call
}

// ApplicationInfo is a helper method to define mock.On call
//   - name
func (_e *Node_Expecter) ApplicationInfo(name interface{}) *Node_ApplicationInfo_Call {
	return &Node_ApplicationInfo_Call{Call: _e.mock.On("ApplicationInfo", name)}
}

func (_c *Node_ApplicationInfo_Call) Run(run func(name gen.Atom)) *Node_ApplicationInfo_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(gen.Atom))
	})
	return _c
}

func (_c *Node_ApplicationInfo_Call) Return(applicationInfo gen.ApplicationInfo, err error) *Node_ApplicationInfo_Call {
	_c.Call.Return(applicationInfo, err)
	return _c
}

func (_c *Node_ApplicationInfo_Call) RunAndReturn(run func(name gen.Atom) (gen.ApplicationInfo, error)) *Node_ApplicationInfo_Call {
	_c.Call.Return(run)
	return _c
}

// ApplicationLoad provides a mock function for the type Node
func (_mock *Node) ApplicationLoad(app gen.ApplicationBehavior, args ...any) (gen.Atom, error) {
	var tmpRet mock.Arguments
	if len(args) > 0 {
		tmpRet = _mock.Called(app, args)
	} else {
		tmpRet = _mock.Called(app)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for ApplicationLoad")
	}

	var r0 gen.Atom
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(gen.ApplicationBehavior, ...any) (gen.Atom, error)); ok {
		return returnFunc(app, args...)
	}
	if returnFunc, ok := ret.Get(0).(func(gen.ApplicationBehavior, ...any) gen.Atom); ok {
		r0 = returnFunc(app, args...)
	} else {
		r0 = ret.Get(0).(gen.Atom)
	}
	if returnFunc, ok := ret.Get(1).(func(gen.ApplicationBehavior, ...any) error); ok {
		r1 = returnFunc(app, args...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Node_ApplicationLoad_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ApplicationLoad'
type Node_ApplicationLoad_Call struct {
	*mock.Call
}

// ApplicationLoad is a helper method to define mock.On call
//   - app
//   - args
func (_e *Node_Expecter) ApplicationLoad(app interface{}, args ...interface{}) *Node_ApplicationLoad_Call {
	return &Node_ApplicationLoad_Call{Call: _e.mock.On("ApplicationLoad",
		append([]interface{}{app}, args...)...)}
}

func (_c *Node_ApplicationLoad_Call) Run(run func(app gen.ApplicationBehavior, args ...any)) *Node_ApplicationLoad_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := args[1].([]any)
		run(args[0].(gen.ApplicationBehavior), variadicArgs...)
	})
	return _c
}

func (_c *Node_ApplicationLoad_Call) Return(atom gen.Atom, err error) *Node_ApplicationLoad_Call {
	_c.Call.Return(atom, err)
	return _c
}

func (_c *Node_ApplicationLoad_Call) RunAndReturn(run func(app gen.ApplicationBehavior, args ...any) (gen.Atom, error)) *Node_ApplicationLoad_Call {
	_c.Call.Return(run)
	return _c
}

// ApplicationStart provides a mock function for the type Node
func (_mock *Node) ApplicationStart(name gen.Atom, options gen.ApplicationOptions) error {
	ret := _mock.Called(name, options)

	if len(ret) == 0 {
		panic("no return value specified for ApplicationStart")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(gen.Atom, gen.ApplicationOptions) error); ok {
		r0 = returnFunc(name, options)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// Node_ApplicationStart_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ApplicationStart'
type Node_ApplicationStart_Call struct {
	*mock.Call
}

// ApplicationStart is a helper method to define mock.On call
//   - name
//   - options
func (_e *Node_Expecter) ApplicationStart(name interface{}, options interface{}) *Node_ApplicationStart_Call {
	return &Node_ApplicationStart_Call{Call: _e.mock.On("ApplicationStart", name, options)}
}

func (_c *Node_ApplicationStart_Call) Run(run func(name gen.Atom, options gen.ApplicationOptions)) *Node_ApplicationStart_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(gen.Atom), args[1].(gen.ApplicationOptions))
	})
	return _c
}

func (_c *Node_ApplicationStart_Call) Return(err error) *Node_ApplicationStart_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *Node_ApplicationStart_Call) RunAndReturn(run func(name gen.Atom, options gen.ApplicationOptions) error) *Node_ApplicationStart_Call {
	_c.Call.Return(run)
	return _c
}

// ApplicationStartPermanent provides a mock function for the type Node
func (_mock *Node) ApplicationStartPermanent(name gen.Atom, options gen.ApplicationOptions) error {
	ret := _mock.Called(name, options)

	if len(ret) == 0 {
		panic("no return value specified for ApplicationStartPermanent")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(gen.Atom, gen.ApplicationOptions) error); ok {
		r0 = returnFunc(name, options)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// Node_ApplicationStartPermanent_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ApplicationStartPermanent'
type Node_ApplicationStartPermanent_Call struct {
	*mock.Call
}

// ApplicationStartPermanent is a helper method to define mock.On call
//   - name
//   - options
func (_e *Node_Expecter) ApplicationStartPermanent(name interface{}, options interface{}) *Node_ApplicationStartPermanent_Call {
	return &Node_ApplicationStartPermanent_Call{Call: _e.mock.On("ApplicationStartPermanent", name, options)}
}

func (_c *Node_ApplicationStartPermanent_Call) Run(run func(name gen.Atom, options gen.ApplicationOptions)) *Node_ApplicationStartPermanent_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(gen.Atom), args[1].(gen.ApplicationOptions))
	})
	return _c
}

func (_c *Node_ApplicationStartPermanent_Call) Return(err error) *Node_ApplicationStartPermanent_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *Node_ApplicationStartPermanent_Call) RunAndReturn(run func(name gen.Atom, options gen.ApplicationOptions) error) *Node_ApplicationStartPermanent_Call {
	_c.Call.Return(run)
	return _c
}

// ApplicationStartTemporary provides a mock function for the type Node
func (_mock *Node) ApplicationStartTemporary(name gen.Atom, options gen.ApplicationOptions) error {
	ret := _mock.Called(name, options)

	if len(ret) == 0 {
		panic("no return value specified for ApplicationStartTemporary")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(gen.Atom, gen.ApplicationOptions) error); ok {
		r0 = returnFunc(name, options)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// Node_ApplicationStartTemporary_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ApplicationStartTemporary'
type Node_ApplicationStartTemporary_Call struct {
	*mock.Call
}

// ApplicationStartTemporary is a helper method to define mock.On call
//   - name
//   - options
func (_e *Node_Expecter) ApplicationStartTemporary(name interface{}, options interface{}) *Node_ApplicationStartTemporary_Call {
	return &Node_ApplicationStartTemporary_Call{Call: _e.mock.On("ApplicationStartTemporary", name, options)}
}

func (_c *Node_ApplicationStartTemporary_Call) Run(run func(name gen.Atom, options gen.ApplicationOptions)) *Node_ApplicationStartTemporary_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(gen.Atom), args[1].(gen.ApplicationOptions))
	})
	return _c
}

func (_c *Node_ApplicationStartTemporary_Call) Return(err error) *Node_ApplicationStartTemporary_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *Node_ApplicationStartTemporary_Call) RunAndReturn(run func(name gen.Atom, options gen.ApplicationOptions) error) *Node_ApplicationStartTemporary_Call {
	_c.Call.Return(run)
	return _c
}

// ApplicationStartTransient provides a mock function for the type Node
func (_mock *Node) ApplicationStartTransient(name gen.Atom, options gen.ApplicationOptions) error {
	ret := _mock.Called(name, options)

	if len(ret) == 0 {
		panic("no return value specified for ApplicationStartTransient")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(gen.Atom, gen.ApplicationOptions) error); ok {
		r0 = returnFunc(name, options)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// Node_ApplicationStartTransient_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ApplicationStartTransient'
type Node_ApplicationStartTransient_Call struct {
	*mock.Call
}

// ApplicationStartTransient is a helper method to define mock.On call
//   - name
//   - options
func (_e *Node_Expecter) ApplicationStartTransient(name interface{}, options interface{}) *Node_ApplicationStartTransient_Call {
	return &Node_ApplicationStartTransient_Call{Call: _e.mock.On("ApplicationStartTransient", name, options)}
}

func (_c *Node_ApplicationStartTransient_Call) Run(run func(name gen.Atom, options gen.ApplicationOptions)) *Node_ApplicationStartTransient_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(gen.Atom), args[1].(gen.ApplicationOptions))
	})
	return _c
}

func (_c *Node_ApplicationStartTransient_Call) Return(err error) *Node_ApplicationStartTransient_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *Node_ApplicationStartTransient_Call) RunAndReturn(run func(name gen.Atom, options gen.ApplicationOptions) error) *Node_ApplicationStartTransient_Call {
	_c.Call.Return(run)
	return _c
}

// ApplicationStop provides a mock function for the type Node
func (_mock *Node) ApplicationStop(name gen.Atom) error {
	ret := _mock.Called(name)

	if len(ret) == 0 {
		panic("no return value specified for ApplicationStop")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(gen.Atom) error); ok {
		r0 = returnFunc(name)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// Node_ApplicationStop_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ApplicationStop'
type Node_ApplicationStop_Call struct {
	*mock.Call
}

// ApplicationStop is a helper method to define mock.On call
//   - name
func (_e *Node_Expecter) ApplicationStop(name interface{}) *Node_ApplicationStop_Call {
	return &Node_ApplicationStop_Call{Call: _e.mock.On("ApplicationStop", name)}
}

func (_c *Node_ApplicationStop_Call) Run(run func(name gen.Atom)) *Node_ApplicationStop_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(gen.Atom))
	})
	return _c
}

func (_c *Node_ApplicationStop_Call) Return(err error) *Node_ApplicationStop_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *Node_ApplicationStop_Call) RunAndReturn(run func(name gen.Atom) error) *Node_ApplicationStop_Call {
	_c.Call.Return(run)
	return _c
}

// ApplicationStopForce provides a mock function for the type Node
func (_mock *Node) ApplicationStopForce(name gen.Atom) error {
	ret := _mock.Called(name)

	if len(ret) == 0 {
		panic("no return value specified for ApplicationStopForce")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(gen.Atom) error); ok {
		r0 = returnFunc(name)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// Node_ApplicationStopForce_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ApplicationStopForce'
type Node_ApplicationStopForce_Call struct {
	*mock.Call
}

// ApplicationStopForce is a helper method to define mock.On call
//   - name
func (_e *Node_Expecter) ApplicationStopForce(name interface{}) *Node_ApplicationStopForce_Call {
	return &Node_ApplicationStopForce_Call{Call: _e.mock.On("ApplicationStopForce", name)}
}

func (_c *Node_ApplicationStopForce_Call) Run(run func(name gen.Atom)) *Node_ApplicationStopForce_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(gen.Atom))
	})
	return _c
}

func (_c *Node_ApplicationStopForce_Call) Return(err error) *Node_ApplicationStopForce_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *Node_ApplicationStopForce_Call) RunAndReturn(run func(name gen.Atom) error) *Node_ApplicationStopForce_Call {
	_c.Call.Return(run)
	return _c
}

// ApplicationStopWithTimeout provides a mock function for the type Node
func (_mock *Node) ApplicationStopWithTimeout(name gen.Atom, timeout time.Duration) error {
	ret := _mock.Called(name, timeout)

	if len(ret) == 0 {
		panic("no return value specified for ApplicationStopWithTimeout")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(gen.Atom, time.Duration) error); ok {
		r0 = returnFunc(name, timeout)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// Node_ApplicationStopWithTimeout_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ApplicationStopWithTimeout'
type Node_ApplicationStopWithTimeout_Call struct {
	*mock.Call
}

// ApplicationStopWithTimeout is a helper method to define mock.On call
//   - name
//   - timeout
func (_e *Node_Expecter) ApplicationStopWithTimeout(name interface{}, timeout interface{}) *Node_ApplicationStopWithTimeout_Call {
	return &Node_ApplicationStopWithTimeout_Call{Call: _e.mock.On("ApplicationStopWithTimeout", name, timeout)}
}

func (_c *Node_ApplicationStopWithTimeout_Call) Run(run func(name gen.Atom, timeout time.Duration)) *Node_ApplicationStopWithTimeout_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(gen.Atom), args[1].(time.Duration))
	})
	return _c
}

func (_c *Node_ApplicationStopWithTimeout_Call) Return(err error) *Node_ApplicationStopWithTimeout_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *Node_ApplicationStopWithTimeout_Call) RunAndReturn(run func(name gen.Atom, timeout time.Duration) error) *Node_ApplicationStopWithTimeout_Call {
	_c.Call.Return(run)
	return _c
}

// ApplicationUnload provides a mock function for the type Node
func (_mock *Node) ApplicationUnload(name gen.Atom) error {
	ret := _mock.Called(name)

	if len(ret) == 0 {
		panic("no return value specified for ApplicationUnload")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(gen.Atom) error); ok {
		r0 = returnFunc(name)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// Node_ApplicationUnload_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ApplicationUnload'
type Node_ApplicationUnload_Call struct {
	*mock.Call
}

// ApplicationUnload is a helper method to define mock.On call
//   - name
func (_e *Node_Expecter) ApplicationUnload(name interface{}) *Node_ApplicationUnload_Call {
	return &Node_ApplicationUnload_Call{Call: _e.mock.On("ApplicationUnload", name)}
}

func (_c *Node_ApplicationUnload_Call) Run(run func(name gen.Atom)) *Node_ApplicationUnload_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(gen.Atom))
	})
	return _c
}

func (_c *Node_ApplicationUnload_Call) Return(err error) *Node_ApplicationUnload_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *Node_ApplicationUnload_Call) RunAndReturn(run func(name gen.Atom) error) *Node_ApplicationUnload_Call {
	_c.Call.Return(run)
	return _c
}

// Applications provides a mock function for the type Node
func (_mock *Node) Applications() []gen.Atom {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Applications")
	}

	var r0 []gen.Atom
	if returnFunc, ok := ret.Get(0).(func() []gen.Atom); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]gen.Atom)
		}
	}
	return r0
}

// Node_Applications_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Applications'
type Node_Applications_Call struct {
	*mock.Call
}

// Applications is a helper method to define mock.On call
func (_e *Node_Expecter) Applications() *Node_Applications_Call {
	return &Node_Applications_Call{Call: _e.mock.On("Applications")}
}

func (_c *Node_Applications_Call) Run(run func()) *Node_Applications_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Node_Applications_Call) Return(atoms []gen.Atom) *Node_Applications_Call {
	_c.Call.Return(atoms)
	return _c
}

func (_c *Node_Applications_Call) RunAndReturn(run func() []gen.Atom) *Node_Applications_Call {
	_c.Call.Return(run)
	return _c
}

// ApplicationsRunning provides a mock function for the type Node
func (_mock *Node) ApplicationsRunning() []gen.Atom {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for ApplicationsRunning")
	}

	var r0 []gen.Atom
	if returnFunc, ok := ret.Get(0).(func() []gen.Atom); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]gen.Atom)
		}
	}
	return r0
}

// Node_ApplicationsRunning_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ApplicationsRunning'
type Node_ApplicationsRunning_Call struct {
	*mock.Call
}

// ApplicationsRunning is a helper method to define mock.On call
func (_e *Node_Expecter) ApplicationsRunning() *Node_ApplicationsRunning_Call {
	return &Node_ApplicationsRunning_Call{Call: _e.mock.On("ApplicationsRunning")}
}

func (_c *Node_ApplicationsRunning_Call) Run(run func()) *Node_ApplicationsRunning_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Node_ApplicationsRunning_Call) Return(atoms []gen.Atom) *Node_ApplicationsRunning_Call {
	_c.Call.Return(atoms)
	return _c
}

func (_c *Node_ApplicationsRunning_Call) RunAndReturn(run func() []gen.Atom) *Node_ApplicationsRunning_Call {
	_c.Call.Return(run)
	return _c
}

// CertManager provides a mock function for the type Node
func (_mock *Node) CertManager() gen.CertManager {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for CertManager")
	}

	var r0 gen.CertManager
	if returnFunc, ok := ret.Get(0).(func() gen.CertManager); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(gen.CertManager)
		}
	}
	return r0
}

// Node_CertManager_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CertManager'
type Node_CertManager_Call struct {
	*mock.Call
}

// CertManager is a helper method to define mock.On call
func (_e *Node_Expecter) CertManager() *Node_CertManager_Call {
	return &Node_CertManager_Call{Call: _e.mock.On("CertManager")}
}

func (_c *Node_CertManager_Call) Run(run func()) *Node_CertManager_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Node_CertManager_Call) Return(certManager gen.CertManager) *Node_CertManager_Call {
	_c.Call.Return(certManager)
	return _c
}

func (_c *Node_CertManager_Call) RunAndReturn(run func() gen.CertManager) *Node_CertManager_Call {
	_c.Call.Return(run)
	return _c
}

// Commercial provides a mock function for the type Node
func (_mock *Node) Commercial() []gen.Version {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Commercial")
	}

	var r0 []gen.Version
	if returnFunc, ok := ret.Get(0).(func() []gen.Version); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]gen.Version)
		}
	}
	return r0
}

// Node_Commercial_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Commercial'
type Node_Commercial_Call struct {
	*mock.Call
}

// Commercial is a helper method to define mock.On call
func (_e *Node_Expecter) Commercial() *Node_Commercial_Call {
	return &Node_Commercial_Call{Call: _e.mock.On("Commercial")}
}

func (_c *Node_Commercial_Call) Run(run func()) *Node_Commercial_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Node_Commercial_Call) Return(versions []gen.Version) *Node_Commercial_Call {
	_c.Call.Return(versions)
	return _c
}

func (_c *Node_Commercial_Call) RunAndReturn(run func() []gen.Version) *Node_Commercial_Call {
	_c.Call.Return(run)
	return _c
}

// Creation provides a mock function for the type Node
func (_mock *Node) Creation() int64 {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Creation")
	}

	var r0 int64
	if returnFunc, ok := ret.Get(0).(func() int64); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(int64)
	}
	return r0
}

// Node_Creation_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Creation'
type Node_Creation_Call struct {
	*mock.Call
}

// Creation is a helper method to define mock.On call
func (_e *Node_Expecter) Creation() *Node_Creation_Call {
	return &Node_Creation_Call{Call: _e.mock.On("Creation")}
}

func (_c *Node_Creation_Call) Run(run func()) *Node_Creation_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Node_Creation_Call) Return(n int64) *Node_Creation_Call {
	_c.Call.Return(n)
	return _c
}

func (_c *Node_Creation_Call) RunAndReturn(run func() int64) *Node_Creation_Call {
	_c.Call.Return(run)
	return _c
}

// Cron provides a mock function for the type Node
func (_mock *Node) Cron() gen.Cron {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Cron")
	}

	var r0 gen.Cron
	if returnFunc, ok := ret.Get(0).(func() gen.Cron); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(gen.Cron)
		}
	}
	return r0
}

// Node_Cron_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Cron'
type Node_Cron_Call struct {
	*mock.Call
}

// Cron is a helper method to define mock.On call
func (_e *Node_Expecter) Cron() *Node_Cron_Call {
	return &Node_Cron_Call{Call: _e.mock.On("Cron")}
}

func (_c *Node_Cron_Call) Run(run func()) *Node_Cron_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Node_Cron_Call) Return(cron gen.Cron) *Node_Cron_Call {
	_c.Call.Return(cron)
	return _c
}

func (_c *Node_Cron_Call) RunAndReturn(run func() gen.Cron) *Node_Cron_Call {
	_c.Call.Return(run)
	return _c
}

// Env provides a mock function for the type Node
func (_mock *Node) Env(name gen.Env) (any, bool) {
	ret := _mock.Called(name)

	if len(ret) == 0 {
		panic("no return value specified for Env")
	}

	var r0 any
	var r1 bool
	if returnFunc, ok := ret.Get(0).(func(gen.Env) (any, bool)); ok {
		return returnFunc(name)
	}
	if returnFunc, ok := ret.Get(0).(func(gen.Env) any); ok {
		r0 = returnFunc(name)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(any)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(gen.Env) bool); ok {
		r1 = returnFunc(name)
	} else {
		r1 = ret.Get(1).(bool)
	}
	return r0, r1
}

// Node_Env_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Env'
type Node_Env_Call struct {
	*mock.Call
}

// Env is a helper method to define mock.On call
//   - name
func (_e *Node_Expecter) Env(name interface{}) *Node_Env_Call {
	return &Node_Env_Call{Call: _e.mock.On("Env", name)}
}

func (_c *Node_Env_Call) Run(run func(name gen.Env)) *Node_Env_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(gen.Env))
	})
	return _c
}

func (_c *Node_Env_Call) Return(v any, b bool) *Node_Env_Call {
	_c.Call.Return(v, b)
	return _c
}

func (_c *Node_Env_Call) RunAndReturn(run func(name gen.Env) (any, bool)) *Node_Env_Call {
	_c.Call.Return(run)
	return _c
}

// EnvDefault provides a mock function for the type Node
func (_mock *Node) EnvDefault(name gen.Env, def any) any {
	ret := _mock.Called(name, def)

	if len(ret) == 0 {
		panic("no return value specified for EnvDefault")
	}

	var r0 any
	if returnFunc, ok := ret.Get(0).(func(gen.Env, any) any); ok {
		r0 = returnFunc(name, def)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(any)
		}
	}
	return r0
}

// Node_EnvDefault_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'EnvDefault'
type Node_EnvDefault_Call struct {
	*mock.Call
}

// EnvDefault is a helper method to define mock.On call
//   - name
//   - def
func (_e *Node_Expecter) EnvDefault(name interface{}, def interface{}) *Node_EnvDefault_Call {
	return &Node_EnvDefault_Call{Call: _e.mock.On("EnvDefault", name, def)}
}

func (_c *Node_EnvDefault_Call) Run(run func(name gen.Env, def any)) *Node_EnvDefault_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(gen.Env), args[1].(any))
	})
	return _c
}

func (_c *Node_EnvDefault_Call) Return(v any) *Node_EnvDefault_Call {
	_c.Call.Return(v)
	return _c
}

func (_c *Node_EnvDefault_Call) RunAndReturn(run func(name gen.Env, def any) any) *Node_EnvDefault_Call {
	_c.Call.Return(run)
	return _c
}

// EnvList provides a mock function for the type Node
func (_mock *Node) EnvList() map[gen.Env]any {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for EnvList")
	}

	var r0 map[gen.Env]any
	if returnFunc, ok := ret.Get(0).(func() map[gen.Env]any); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[gen.Env]any)
		}
	}
	return r0
}

// Node_EnvList_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'EnvList'
type Node_EnvList_Call struct {
	*mock.Call
}

// EnvList is a helper method to define mock.On call
func (_e *Node_Expecter) EnvList() *Node_EnvList_Call {
	return &Node_EnvList_Call{Call: _e.mock.On("EnvList")}
}

func (_c *Node_EnvList_Call) Run(run func()) *Node_EnvList_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Node_EnvList_Call) Return(envToV map[gen.Env]any) *Node_EnvList_Call {
	_c.Call.Return(envToV)
	return _c
}

func (_c *Node_EnvList_Call) RunAndReturn(run func() map[gen.Env]any) *Node_EnvList_Call {
	_c.Call.Return(run)
	return _c
}

// FrameworkVersion provides a mock function for the type Node
func (_mock *Node) FrameworkVersion() gen.Version {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for FrameworkVersion")
	}

	var r0 gen.Version
	if returnFunc, ok := ret.Get(0).(func() gen.Version); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(gen.Version)
	}
	return r0
}

// Node_FrameworkVersion_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FrameworkVersion'
type Node_FrameworkVersion_Call struct {
	*mock.Call
}

// FrameworkVersion is a helper method to define mock.On call
func (_e *Node_Expecter) FrameworkVersion() *Node_FrameworkVersion_Call {
	return &Node_FrameworkVersion_Call{Call: _e.mock.On("FrameworkVersion")}
}

func (_c *Node_FrameworkVersion_Call) Run(run func()) *Node_FrameworkVersion_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Node_FrameworkVersion_Call) Return(version gen.Version) *Node_FrameworkVersion_Call {
	_c.Call.Return(version)
	return _c
}

func (_c *Node_FrameworkVersion_Call) RunAndReturn(run func() gen.Version) *Node_FrameworkVersion_Call {
	_c.Call.Return(run)
	return _c
}

// Info provides a mock function for the type Node
func (_mock *Node) Info() (gen.NodeInfo, error) {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Info")
	}

	var r0 gen.NodeInfo
	var r1 error
	if returnFunc, ok := ret.Get(0).(func() (gen.NodeInfo, error)); ok {
		return returnFunc()
	}
	if returnFunc, ok := ret.Get(0).(func() gen.NodeInfo); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(gen.NodeInfo)
	}
	if returnFunc, ok := ret.Get(1).(func() error); ok {
		r1 = returnFunc()
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Node_Info_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Info'
type Node_Info_Call struct {
	*mock.Call
}

// Info is a helper method to define mock.On call
func (_e *Node_Expecter) Info() *Node_Info_Call {
	return &Node_Info_Call{Call: _e.mock.On("Info")}
}

func (_c *Node_Info_Call) Run(run func()) *Node_Info_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Node_Info_Call) Return(nodeInfo gen.NodeInfo, err error) *Node_Info_Call {
	_c.Call.Return(nodeInfo, err)
	return _c
}

func (_c *Node_Info_Call) RunAndReturn(run func() (gen.NodeInfo, error)) *Node_Info_Call {
	_c.Call.Return(run)
	return _c
}

// IsAlive provides a mock function for the type Node
func (_mock *Node) IsAlive() bool {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for IsAlive")
	}

	var r0 bool
	if returnFunc, ok := ret.Get(0).(func() bool); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(bool)
	}
	return r0
}

// Node_IsAlive_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'IsAlive'
type Node_IsAlive_Call struct {
	*mock.Call
}

// IsAlive is a helper method to define mock.On call
func (_e *Node_Expecter) IsAlive() *Node_IsAlive_Call {
	return &Node_IsAlive_Call{Call: _e.mock.On("IsAlive")}
}

func (_c *Node_IsAlive_Call) Run(run func()) *Node_IsAlive_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Node_IsAlive_Call) Return(b bool) *Node_IsAlive_Call {
	_c.Call.Return(b)
	return _c
}

func (_c *Node_IsAlive_Call) RunAndReturn(run func() bool) *Node_IsAlive_Call {
	_c.Call.Return(run)
	return _c
}

// Kill provides a mock function for the type Node
func (_mock *Node) Kill(pid gen.PID) error {
	ret := _mock.Called(pid)

	if len(ret) == 0 {
		panic("no return value specified for Kill")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(gen.PID) error); ok {
		r0 = returnFunc(pid)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// Node_Kill_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Kill'
type Node_Kill_Call struct {
	*mock.Call
}

// Kill is a helper method to define mock.On call
//   - pid
func (_e *Node_Expecter) Kill(pid interface{}) *Node_Kill_Call {
	return &Node_Kill_Call{Call: _e.mock.On("Kill", pid)}
}

func (_c *Node_Kill_Call) Run(run func(pid gen.PID)) *Node_Kill_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(gen.PID))
	})
	return _c
}

func (_c *Node_Kill_Call) Return(err error) *Node_Kill_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *Node_Kill_Call) RunAndReturn(run func(pid gen.PID) error) *Node_Kill_Call {
	_c.Call.Return(run)
	return _c
}

// Log provides a mock function for the type Node
func (_mock *Node) Log() gen.Log {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Log")
	}

	var r0 gen.Log
	if returnFunc, ok := ret.Get(0).(func() gen.Log); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(gen.Log)
		}
	}
	return r0
}

// Node_Log_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Log'
type Node_Log_Call struct {
	*mock.Call
}

// Log is a helper method to define mock.On call
func (_e *Node_Expecter) Log() *Node_Log_Call {
	return &Node_Log_Call{Call: _e.mock.On("Log")}
}

func (_c *Node_Log_Call) Run(run func()) *Node_Log_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Node_Log_Call) Return(log gen.Log) *Node_Log_Call {
	_c.Call.Return(log)
	return _c
}

func (_c *Node_Log_Call) RunAndReturn(run func() gen.Log) *Node_Log_Call {
	_c.Call.Return(run)
	return _c
}

// LogLevelMeta provides a mock function for the type Node
func (_mock *Node) LogLevelMeta(meta gen.Alias) (gen.LogLevel, error) {
	ret := _mock.Called(meta)

	if len(ret) == 0 {
		panic("no return value specified for LogLevelMeta")
	}

	var r0 gen.LogLevel
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(gen.Alias) (gen.LogLevel, error)); ok {
		return returnFunc(meta)
	}
	if returnFunc, ok := ret.Get(0).(func(gen.Alias) gen.LogLevel); ok {
		r0 = returnFunc(meta)
	} else {
		r0 = ret.Get(0).(gen.LogLevel)
	}
	if returnFunc, ok := ret.Get(1).(func(gen.Alias) error); ok {
		r1 = returnFunc(meta)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Node_LogLevelMeta_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LogLevelMeta'
type Node_LogLevelMeta_Call struct {
	*mock.Call
}

// LogLevelMeta is a helper method to define mock.On call
//   - meta
func (_e *Node_Expecter) LogLevelMeta(meta interface{}) *Node_LogLevelMeta_Call {
	return &Node_LogLevelMeta_Call{Call: _e.mock.On("LogLevelMeta", meta)}
}

func (_c *Node_LogLevelMeta_Call) Run(run func(meta gen.Alias)) *Node_LogLevelMeta_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(gen.Alias))
	})
	return _c
}

func (_c *Node_LogLevelMeta_Call) Return(logLevel gen.LogLevel, err error) *Node_LogLevelMeta_Call {
	_c.Call.Return(logLevel, err)
	return _c
}

func (_c *Node_LogLevelMeta_Call) RunAndReturn(run func(meta gen.Alias) (gen.LogLevel, error)) *Node_LogLevelMeta_Call {
	_c.Call.Return(run)
	return _c
}

// LogLevelProcess provides a mock function for the type Node
func (_mock *Node) LogLevelProcess(pid gen.PID) (gen.LogLevel, error) {
	ret := _mock.Called(pid)

	if len(ret) == 0 {
		panic("no return value specified for LogLevelProcess")
	}

	var r0 gen.LogLevel
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(gen.PID) (gen.LogLevel, error)); ok {
		return returnFunc(pid)
	}
	if returnFunc, ok := ret.Get(0).(func(gen.PID) gen.LogLevel); ok {
		r0 = returnFunc(pid)
	} else {
		r0 = ret.Get(0).(gen.LogLevel)
	}
	if returnFunc, ok := ret.Get(1).(func(gen.PID) error); ok {
		r1 = returnFunc(pid)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Node_LogLevelProcess_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LogLevelProcess'
type Node_LogLevelProcess_Call struct {
	*mock.Call
}

// LogLevelProcess is a helper method to define mock.On call
//   - pid
func (_e *Node_Expecter) LogLevelProcess(pid interface{}) *Node_LogLevelProcess_Call {
	return &Node_LogLevelProcess_Call{Call: _e.mock.On("LogLevelProcess", pid)}
}

func (_c *Node_LogLevelProcess_Call) Run(run func(pid gen.PID)) *Node_LogLevelProcess_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(gen.PID))
	})
	return _c
}

func (_c *Node_LogLevelProcess_Call) Return(logLevel gen.LogLevel, err error) *Node_LogLevelProcess_Call {
	_c.Call.Return(logLevel, err)
	return _c
}

func (_c *Node_LogLevelProcess_Call) RunAndReturn(run func(pid gen.PID) (gen.LogLevel, error)) *Node_LogLevelProcess_Call {
	_c.Call.Return(run)
	return _c
}

// LoggerAdd provides a mock function for the type Node
func (_mock *Node) LoggerAdd(name string, logger gen.LoggerBehavior, filter ...gen.LogLevel) error {
	var tmpRet mock.Arguments
	if len(filter) > 0 {
		tmpRet = _mock.Called(name, logger, filter)
	} else {
		tmpRet = _mock.Called(name, logger)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for LoggerAdd")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(string, gen.LoggerBehavior, ...gen.LogLevel) error); ok {
		r0 = returnFunc(name, logger, filter...)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// Node_LoggerAdd_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LoggerAdd'
type Node_LoggerAdd_Call struct {
	*mock.Call
}

// LoggerAdd is a helper method to define mock.On call
//   - name
//   - logger
//   - filter
func (_e *Node_Expecter) LoggerAdd(name interface{}, logger interface{}, filter ...interface{}) *Node_LoggerAdd_Call {
	return &Node_LoggerAdd_Call{Call: _e.mock.On("LoggerAdd",
		append([]interface{}{name, logger}, filter...)...)}
}

func (_c *Node_LoggerAdd_Call) Run(run func(name string, logger gen.LoggerBehavior, filter ...gen.LogLevel)) *Node_LoggerAdd_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := args[2].([]gen.LogLevel)
		run(args[0].(string), args[1].(gen.LoggerBehavior), variadicArgs...)
	})
	return _c
}

func (_c *Node_LoggerAdd_Call) Return(err error) *Node_LoggerAdd_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *Node_LoggerAdd_Call) RunAndReturn(run func(name string, logger gen.LoggerBehavior, filter ...gen.LogLevel) error) *Node_LoggerAdd_Call {
	_c.Call.Return(run)
	return _c
}

// LoggerAddPID provides a mock function for the type Node
func (_mock *Node) LoggerAddPID(pid gen.PID, name string, filter ...gen.LogLevel) error {
	var tmpRet mock.Arguments
	if len(filter) > 0 {
		tmpRet = _mock.Called(pid, name, filter)
	} else {
		tmpRet = _mock.Called(pid, name)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for LoggerAddPID")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(gen.PID, string, ...gen.LogLevel) error); ok {
		r0 = returnFunc(pid, name, filter...)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// Node_LoggerAddPID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LoggerAddPID'
type Node_LoggerAddPID_Call struct {
	*mock.Call
}

// LoggerAddPID is a helper method to define mock.On call
//   - pid
//   - name
//   - filter
func (_e *Node_Expecter) LoggerAddPID(pid interface{}, name interface{}, filter ...interface{}) *Node_LoggerAddPID_Call {
	return &Node_LoggerAddPID_Call{Call: _e.mock.On("LoggerAddPID",
		append([]interface{}{pid, name}, filter...)...)}
}

func (_c *Node_LoggerAddPID_Call) Run(run func(pid gen.PID, name string, filter ...gen.LogLevel)) *Node_LoggerAddPID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := args[2].([]gen.LogLevel)
		run(args[0].(gen.PID), args[1].(string), variadicArgs...)
	})
	return _c
}

func (_c *Node_LoggerAddPID_Call) Return(err error) *Node_LoggerAddPID_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *Node_LoggerAddPID_Call) RunAndReturn(run func(pid gen.PID, name string, filter ...gen.LogLevel) error) *Node_LoggerAddPID_Call {
	_c.Call.Return(run)
	return _c
}

// LoggerDelete provides a mock function for the type Node
func (_mock *Node) LoggerDelete(name string) {
	_mock.Called(name)
	return
}

// Node_LoggerDelete_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LoggerDelete'
type Node_LoggerDelete_Call struct {
	*mock.Call
}

// LoggerDelete is a helper method to define mock.On call
//   - name
func (_e *Node_Expecter) LoggerDelete(name interface{}) *Node_LoggerDelete_Call {
	return &Node_LoggerDelete_Call{Call: _e.mock.On("LoggerDelete", name)}
}

func (_c *Node_LoggerDelete_Call) Run(run func(name string)) *Node_LoggerDelete_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *Node_LoggerDelete_Call) Return() *Node_LoggerDelete_Call {
	_c.Call.Return()
	return _c
}

func (_c *Node_LoggerDelete_Call) RunAndReturn(run func(name string)) *Node_LoggerDelete_Call {
	_c.Run(run)
	return _c
}

// LoggerDeletePID provides a mock function for the type Node
func (_mock *Node) LoggerDeletePID(pid gen.PID) {
	_mock.Called(pid)
	return
}

// Node_LoggerDeletePID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LoggerDeletePID'
type Node_LoggerDeletePID_Call struct {
	*mock.Call
}

// LoggerDeletePID is a helper method to define mock.On call
//   - pid
func (_e *Node_Expecter) LoggerDeletePID(pid interface{}) *Node_LoggerDeletePID_Call {
	return &Node_LoggerDeletePID_Call{Call: _e.mock.On("LoggerDeletePID", pid)}
}

func (_c *Node_LoggerDeletePID_Call) Run(run func(pid gen.PID)) *Node_LoggerDeletePID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(gen.PID))
	})
	return _c
}

func (_c *Node_LoggerDeletePID_Call) Return() *Node_LoggerDeletePID_Call {
	_c.Call.Return()
	return _c
}

func (_c *Node_LoggerDeletePID_Call) RunAndReturn(run func(pid gen.PID)) *Node_LoggerDeletePID_Call {
	_c.Run(run)
	return _c
}

// LoggerLevels provides a mock function for the type Node
func (_mock *Node) LoggerLevels(name string) []gen.LogLevel {
	ret := _mock.Called(name)

	if len(ret) == 0 {
		panic("no return value specified for LoggerLevels")
	}

	var r0 []gen.LogLevel
	if returnFunc, ok := ret.Get(0).(func(string) []gen.LogLevel); ok {
		r0 = returnFunc(name)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]gen.LogLevel)
		}
	}
	return r0
}

// Node_LoggerLevels_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LoggerLevels'
type Node_LoggerLevels_Call struct {
	*mock.Call
}

// LoggerLevels is a helper method to define mock.On call
//   - name
func (_e *Node_Expecter) LoggerLevels(name interface{}) *Node_LoggerLevels_Call {
	return &Node_LoggerLevels_Call{Call: _e.mock.On("LoggerLevels", name)}
}

func (_c *Node_LoggerLevels_Call) Run(run func(name string)) *Node_LoggerLevels_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *Node_LoggerLevels_Call) Return(logLevels []gen.LogLevel) *Node_LoggerLevels_Call {
	_c.Call.Return(logLevels)
	return _c
}

func (_c *Node_LoggerLevels_Call) RunAndReturn(run func(name string) []gen.LogLevel) *Node_LoggerLevels_Call {
	_c.Call.Return(run)
	return _c
}

// Loggers provides a mock function for the type Node
func (_mock *Node) Loggers() []string {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Loggers")
	}

	var r0 []string
	if returnFunc, ok := ret.Get(0).(func() []string); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}
	return r0
}

// Node_Loggers_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Loggers'
type Node_Loggers_Call struct {
	*mock.Call
}

// Loggers is a helper method to define mock.On call
func (_e *Node_Expecter) Loggers() *Node_Loggers_Call {
	return &Node_Loggers_Call{Call: _e.mock.On("Loggers")}
}

func (_c *Node_Loggers_Call) Run(run func()) *Node_Loggers_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Node_Loggers_Call) Return(strings []string) *Node_Loggers_Call {
	_c.Call.Return(strings)
	return _c
}

func (_c *Node_Loggers_Call) RunAndReturn(run func() []string) *Node_Loggers_Call {
	_c.Call.Return(run)
	return _c
}

// MakeRef provides a mock function for the type Node
func (_mock *Node) MakeRef() gen.Ref {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for MakeRef")
	}

	var r0 gen.Ref
	if returnFunc, ok := ret.Get(0).(func() gen.Ref); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(gen.Ref)
	}
	return r0
}

// Node_MakeRef_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'MakeRef'
type Node_MakeRef_Call struct {
	*mock.Call
}

// MakeRef is a helper method to define mock.On call
func (_e *Node_Expecter) MakeRef() *Node_MakeRef_Call {
	return &Node_MakeRef_Call{Call: _e.mock.On("MakeRef")}
}

func (_c *Node_MakeRef_Call) Run(run func()) *Node_MakeRef_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Node_MakeRef_Call) Return(ref gen.Ref) *Node_MakeRef_Call {
	_c.Call.Return(ref)
	return _c
}

func (_c *Node_MakeRef_Call) RunAndReturn(run func() gen.Ref) *Node_MakeRef_Call {
	_c.Call.Return(run)
	return _c
}

// MetaInfo provides a mock function for the type Node
func (_mock *Node) MetaInfo(meta gen.Alias) (gen.MetaInfo, error) {
	ret := _mock.Called(meta)

	if len(ret) == 0 {
		panic("no return value specified for MetaInfo")
	}

	var r0 gen.MetaInfo
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(gen.Alias) (gen.MetaInfo, error)); ok {
		return returnFunc(meta)
	}
	if returnFunc, ok := ret.Get(0).(func(gen.Alias) gen.MetaInfo); ok {
		r0 = returnFunc(meta)
	} else {
		r0 = ret.Get(0).(gen.MetaInfo)
	}
	if returnFunc, ok := ret.Get(1).(func(gen.Alias) error); ok {
		r1 = returnFunc(meta)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Node_MetaInfo_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'MetaInfo'
type Node_MetaInfo_Call struct {
	*mock.Call
}

// MetaInfo is a helper method to define mock.On call
//   - meta
func (_e *Node_Expecter) MetaInfo(meta interface{}) *Node_MetaInfo_Call {
	return &Node_MetaInfo_Call{Call: _e.mock.On("MetaInfo", meta)}
}

func (_c *Node_MetaInfo_Call) Run(run func(meta gen.Alias)) *Node_MetaInfo_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(gen.Alias))
	})
	return _c
}

func (_c *Node_MetaInfo_Call) Return(metaInfo gen.MetaInfo, err error) *Node_MetaInfo_Call {
	_c.Call.Return(metaInfo, err)
	return _c
}

func (_c *Node_MetaInfo_Call) RunAndReturn(run func(meta gen.Alias) (gen.MetaInfo, error)) *Node_MetaInfo_Call {
	_c.Call.Return(run)
	return _c
}

// Name provides a mock function for the type Node
func (_mock *Node) Name() gen.Atom {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Name")
	}

	var r0 gen.Atom
	if returnFunc, ok := ret.Get(0).(func() gen.Atom); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(gen.Atom)
	}
	return r0
}

// Node_Name_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Name'
type Node_Name_Call struct {
	*mock.Call
}

// Name is a helper method to define mock.On call
func (_e *Node_Expecter) Name() *Node_Name_Call {
	return &Node_Name_Call{Call: _e.mock.On("Name")}
}

func (_c *Node_Name_Call) Run(run func()) *Node_Name_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Node_Name_Call) Return(atom gen.Atom) *Node_Name_Call {
	_c.Call.Return(atom)
	return _c
}

func (_c *Node_Name_Call) RunAndReturn(run func() gen.Atom) *Node_Name_Call {
	_c.Call.Return(run)
	return _c
}

// Network provides a mock function for the type Node
func (_mock *Node) Network() gen.Network {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Network")
	}

	var r0 gen.Network
	if returnFunc, ok := ret.Get(0).(func() gen.Network); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(gen.Network)
		}
	}
	return r0
}

// Node_Network_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Network'
type Node_Network_Call struct {
	*mock.Call
}

// Network is a helper method to define mock.On call
func (_e *Node_Expecter) Network() *Node_Network_Call {
	return &Node_Network_Call{Call: _e.mock.On("Network")}
}

func (_c *Node_Network_Call) Run(run func()) *Node_Network_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Node_Network_Call) Return(network gen.Network) *Node_Network_Call {
	_c.Call.Return(network)
	return _c
}

func (_c *Node_Network_Call) RunAndReturn(run func() gen.Network) *Node_Network_Call {
	_c.Call.Return(run)
	return _c
}

// NetworkStart provides a mock function for the type Node
func (_mock *Node) NetworkStart(options gen.NetworkOptions) error {
	ret := _mock.Called(options)

	if len(ret) == 0 {
		panic("no return value specified for NetworkStart")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(gen.NetworkOptions) error); ok {
		r0 = returnFunc(options)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// Node_NetworkStart_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'NetworkStart'
type Node_NetworkStart_Call struct {
	*mock.Call
}

// NetworkStart is a helper method to define mock.On call
//   - options
func (_e *Node_Expecter) NetworkStart(options interface{}) *Node_NetworkStart_Call {
	return &Node_NetworkStart_Call{Call: _e.mock.On("NetworkStart", options)}
}

func (_c *Node_NetworkStart_Call) Run(run func(options gen.NetworkOptions)) *Node_NetworkStart_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(gen.NetworkOptions))
	})
	return _c
}

func (_c *Node_NetworkStart_Call) Return(err error) *Node_NetworkStart_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *Node_NetworkStart_Call) RunAndReturn(run func(options gen.NetworkOptions) error) *Node_NetworkStart_Call {
	_c.Call.Return(run)
	return _c
}

// NetworkStop provides a mock function for the type Node
func (_mock *Node) NetworkStop() error {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for NetworkStop")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func() error); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// Node_NetworkStop_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'NetworkStop'
type Node_NetworkStop_Call struct {
	*mock.Call
}

// NetworkStop is a helper method to define mock.On call
func (_e *Node_Expecter) NetworkStop() *Node_NetworkStop_Call {
	return &Node_NetworkStop_Call{Call: _e.mock.On("NetworkStop")}
}

func (_c *Node_NetworkStop_Call) Run(run func()) *Node_NetworkStop_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Node_NetworkStop_Call) Return(err error) *Node_NetworkStop_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *Node_NetworkStop_Call) RunAndReturn(run func() error) *Node_NetworkStop_Call {
	_c.Call.Return(run)
	return _c
}

// PID provides a mock function for the type Node
func (_mock *Node) PID() gen.PID {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for PID")
	}

	var r0 gen.PID
	if returnFunc, ok := ret.Get(0).(func() gen.PID); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(gen.PID)
	}
	return r0
}

// Node_PID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PID'
type Node_PID_Call struct {
	*mock.Call
}

// PID is a helper method to define mock.On call
func (_e *Node_Expecter) PID() *Node_PID_Call {
	return &Node_PID_Call{Call: _e.mock.On("PID")}
}

func (_c *Node_PID_Call) Run(run func()) *Node_PID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Node_PID_Call) Return(pID gen.PID) *Node_PID_Call {
	_c.Call.Return(pID)
	return _c
}

func (_c *Node_PID_Call) RunAndReturn(run func() gen.PID) *Node_PID_Call {
	_c.Call.Return(run)
	return _c
}

// ProcessInfo provides a mock function for the type Node
func (_mock *Node) ProcessInfo(pid gen.PID) (gen.ProcessInfo, error) {
	ret := _mock.Called(pid)

	if len(ret) == 0 {
		panic("no return value specified for ProcessInfo")
	}

	var r0 gen.ProcessInfo
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(gen.PID) (gen.ProcessInfo, error)); ok {
		return returnFunc(pid)
	}
	if returnFunc, ok := ret.Get(0).(func(gen.PID) gen.ProcessInfo); ok {
		r0 = returnFunc(pid)
	} else {
		r0 = ret.Get(0).(gen.ProcessInfo)
	}
	if returnFunc, ok := ret.Get(1).(func(gen.PID) error); ok {
		r1 = returnFunc(pid)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Node_ProcessInfo_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ProcessInfo'
type Node_ProcessInfo_Call struct {
	*mock.Call
}

// ProcessInfo is a helper method to define mock.On call
//   - pid
func (_e *Node_Expecter) ProcessInfo(pid interface{}) *Node_ProcessInfo_Call {
	return &Node_ProcessInfo_Call{Call: _e.mock.On("ProcessInfo", pid)}
}

func (_c *Node_ProcessInfo_Call) Run(run func(pid gen.PID)) *Node_ProcessInfo_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(gen.PID))
	})
	return _c
}

func (_c *Node_ProcessInfo_Call) Return(processInfo gen.ProcessInfo, err error) *Node_ProcessInfo_Call {
	_c.Call.Return(processInfo, err)
	return _c
}

func (_c *Node_ProcessInfo_Call) RunAndReturn(run func(pid gen.PID) (gen.ProcessInfo, error)) *Node_ProcessInfo_Call {
	_c.Call.Return(run)
	return _c
}

// ProcessList provides a mock function for the type Node
func (_mock *Node) ProcessList() ([]gen.PID, error) {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for ProcessList")
	}

	var r0 []gen.PID
	var r1 error
	if returnFunc, ok := ret.Get(0).(func() ([]gen.PID, error)); ok {
		return returnFunc()
	}
	if returnFunc, ok := ret.Get(0).(func() []gen.PID); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]gen.PID)
		}
	}
	if returnFunc, ok := ret.Get(1).(func() error); ok {
		r1 = returnFunc()
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Node_ProcessList_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ProcessList'
type Node_ProcessList_Call struct {
	*mock.Call
}

// ProcessList is a helper method to define mock.On call
func (_e *Node_Expecter) ProcessList() *Node_ProcessList_Call {
	return &Node_ProcessList_Call{Call: _e.mock.On("ProcessList")}
}

func (_c *Node_ProcessList_Call) Run(run func()) *Node_ProcessList_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Node_ProcessList_Call) Return(pIDs []gen.PID, err error) *Node_ProcessList_Call {
	_c.Call.Return(pIDs, err)
	return _c
}

func (_c *Node_ProcessList_Call) RunAndReturn(run func() ([]gen.PID, error)) *Node_ProcessList_Call {
	_c.Call.Return(run)
	return _c
}

// ProcessListShortInfo provides a mock function for the type Node
func (_mock *Node) ProcessListShortInfo(start int, limit int) ([]gen.ProcessShortInfo, error) {
	ret := _mock.Called(start, limit)

	if len(ret) == 0 {
		panic("no return value specified for ProcessListShortInfo")
	}

	var r0 []gen.ProcessShortInfo
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(int, int) ([]gen.ProcessShortInfo, error)); ok {
		return returnFunc(start, limit)
	}
	if returnFunc, ok := ret.Get(0).(func(int, int) []gen.ProcessShortInfo); ok {
		r0 = returnFunc(start, limit)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]gen.ProcessShortInfo)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(int, int) error); ok {
		r1 = returnFunc(start, limit)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Node_ProcessListShortInfo_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ProcessListShortInfo'
type Node_ProcessListShortInfo_Call struct {
	*mock.Call
}

// ProcessListShortInfo is a helper method to define mock.On call
//   - start
//   - limit
func (_e *Node_Expecter) ProcessListShortInfo(start interface{}, limit interface{}) *Node_ProcessListShortInfo_Call {
	return &Node_ProcessListShortInfo_Call{Call: _e.mock.On("ProcessListShortInfo", start, limit)}
}

func (_c *Node_ProcessListShortInfo_Call) Run(run func(start int, limit int)) *Node_ProcessListShortInfo_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(int), args[1].(int))
	})
	return _c
}

func (_c *Node_ProcessListShortInfo_Call) Return(processShortInfos []gen.ProcessShortInfo, err error) *Node_ProcessListShortInfo_Call {
	_c.Call.Return(processShortInfos, err)
	return _c
}

func (_c *Node_ProcessListShortInfo_Call) RunAndReturn(run func(start int, limit int) ([]gen.ProcessShortInfo, error)) *Node_ProcessListShortInfo_Call {
	_c.Call.Return(run)
	return _c
}

// ProcessState provides a mock function for the type Node
func (_mock *Node) ProcessState(pid gen.PID) (gen.ProcessState, error) {
	ret := _mock.Called(pid)

	if len(ret) == 0 {
		panic("no return value specified for ProcessState")
	}

	var r0 gen.ProcessState
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(gen.PID) (gen.ProcessState, error)); ok {
		return returnFunc(pid)
	}
	if returnFunc, ok := ret.Get(0).(func(gen.PID) gen.ProcessState); ok {
		r0 = returnFunc(pid)
	} else {
		r0 = ret.Get(0).(gen.ProcessState)
	}
	if returnFunc, ok := ret.Get(1).(func(gen.PID) error); ok {
		r1 = returnFunc(pid)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Node_ProcessState_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ProcessState'
type Node_ProcessState_Call struct {
	*mock.Call
}

// ProcessState is a helper method to define mock.On call
//   - pid
func (_e *Node_Expecter) ProcessState(pid interface{}) *Node_ProcessState_Call {
	return &Node_ProcessState_Call{Call: _e.mock.On("ProcessState", pid)}
}

func (_c *Node_ProcessState_Call) Run(run func(pid gen.PID)) *Node_ProcessState_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(gen.PID))
	})
	return _c
}

func (_c *Node_ProcessState_Call) Return(processState gen.ProcessState, err error) *Node_ProcessState_Call {
	_c.Call.Return(processState, err)
	return _c
}

func (_c *Node_ProcessState_Call) RunAndReturn(run func(pid gen.PID) (gen.ProcessState, error)) *Node_ProcessState_Call {
	_c.Call.Return(run)
	return _c
}

// RegisterEvent provides a mock function for the type Node
func (_mock *Node) RegisterEvent(name gen.Atom, options gen.EventOptions) (gen.Ref, error) {
	ret := _mock.Called(name, options)

	if len(ret) == 0 {
		panic("no return value specified for RegisterEvent")
	}

	var r0 gen.Ref
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(gen.Atom, gen.EventOptions) (gen.Ref, error)); ok {
		return returnFunc(name, options)
	}
	if returnFunc, ok := ret.Get(0).(func(gen.Atom, gen.EventOptions) gen.Ref); ok {
		r0 = returnFunc(name, options)
	} else {
		r0 = ret.Get(0).(gen.Ref)
	}
	if returnFunc, ok := ret.Get(1).(func(gen.Atom, gen.EventOptions) error); ok {
		r1 = returnFunc(name, options)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Node_RegisterEvent_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RegisterEvent'
type Node_RegisterEvent_Call struct {
	*mock.Call
}

// RegisterEvent is a helper method to define mock.On call
//   - name
//   - options
func (_e *Node_Expecter) RegisterEvent(name interface{}, options interface{}) *Node_RegisterEvent_Call {
	return &Node_RegisterEvent_Call{Call: _e.mock.On("RegisterEvent", name, options)}
}

func (_c *Node_RegisterEvent_Call) Run(run func(name gen.Atom, options gen.EventOptions)) *Node_RegisterEvent_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(gen.Atom), args[1].(gen.EventOptions))
	})
	return _c
}

func (_c *Node_RegisterEvent_Call) Return(ref gen.Ref, err error) *Node_RegisterEvent_Call {
	_c.Call.Return(ref, err)
	return _c
}

func (_c *Node_RegisterEvent_Call) RunAndReturn(run func(name gen.Atom, options gen.EventOptions) (gen.Ref, error)) *Node_RegisterEvent_Call {
	_c.Call.Return(run)
	return _c
}

// RegisterName provides a mock function for the type Node
func (_mock *Node) RegisterName(name gen.Atom, pid gen.PID) error {
	ret := _mock.Called(name, pid)

	if len(ret) == 0 {
		panic("no return value specified for RegisterName")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(gen.Atom, gen.PID) error); ok {
		r0 = returnFunc(name, pid)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// Node_RegisterName_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RegisterName'
type Node_RegisterName_Call struct {
	*mock.Call
}

// RegisterName is a helper method to define mock.On call
//   - name
//   - pid
func (_e *Node_Expecter) RegisterName(name interface{}, pid interface{}) *Node_RegisterName_Call {
	return &Node_RegisterName_Call{Call: _e.mock.On("RegisterName", name, pid)}
}

func (_c *Node_RegisterName_Call) Run(run func(name gen.Atom, pid gen.PID)) *Node_RegisterName_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(gen.Atom), args[1].(gen.PID))
	})
	return _c
}

func (_c *Node_RegisterName_Call) Return(err error) *Node_RegisterName_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *Node_RegisterName_Call) RunAndReturn(run func(name gen.Atom, pid gen.PID) error) *Node_RegisterName_Call {
	_c.Call.Return(run)
	return _c
}

// Security provides a mock function for the type Node
func (_mock *Node) Security() gen.SecurityOptions {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Security")
	}

	var r0 gen.SecurityOptions
	if returnFunc, ok := ret.Get(0).(func() gen.SecurityOptions); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(gen.SecurityOptions)
	}
	return r0
}

// Node_Security_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Security'
type Node_Security_Call struct {
	*mock.Call
}

// Security is a helper method to define mock.On call
func (_e *Node_Expecter) Security() *Node_Security_Call {
	return &Node_Security_Call{Call: _e.mock.On("Security")}
}

func (_c *Node_Security_Call) Run(run func()) *Node_Security_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Node_Security_Call) Return(securityOptions gen.SecurityOptions) *Node_Security_Call {
	_c.Call.Return(securityOptions)
	return _c
}

func (_c *Node_Security_Call) RunAndReturn(run func() gen.SecurityOptions) *Node_Security_Call {
	_c.Call.Return(run)
	return _c
}

// Send provides a mock function for the type Node
func (_mock *Node) Send(to any, message any) error {
	ret := _mock.Called(to, message)

	if len(ret) == 0 {
		panic("no return value specified for Send")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(any, any) error); ok {
		r0 = returnFunc(to, message)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// Node_Send_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Send'
type Node_Send_Call struct {
	*mock.Call
}

// Send is a helper method to define mock.On call
//   - to
//   - message
func (_e *Node_Expecter) Send(to interface{}, message interface{}) *Node_Send_Call {
	return &Node_Send_Call{Call: _e.mock.On("Send", to, message)}
}

func (_c *Node_Send_Call) Run(run func(to any, message any)) *Node_Send_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(any), args[1].(any))
	})
	return _c
}

func (_c *Node_Send_Call) Return(err error) *Node_Send_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *Node_Send_Call) RunAndReturn(run func(to any, message any) error) *Node_Send_Call {
	_c.Call.Return(run)
	return _c
}

// SendEvent provides a mock function for the type Node
func (_mock *Node) SendEvent(name gen.Atom, token gen.Ref, options gen.MessageOptions, message any) error {
	ret := _mock.Called(name, token, options, message)

	if len(ret) == 0 {
		panic("no return value specified for SendEvent")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(gen.Atom, gen.Ref, gen.MessageOptions, any) error); ok {
		r0 = returnFunc(name, token, options, message)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// Node_SendEvent_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SendEvent'
type Node_SendEvent_Call struct {
	*mock.Call
}

// SendEvent is a helper method to define mock.On call
//   - name
//   - token
//   - options
//   - message
func (_e *Node_Expecter) SendEvent(name interface{}, token interface{}, options interface{}, message interface{}) *Node_SendEvent_Call {
	return &Node_SendEvent_Call{Call: _e.mock.On("SendEvent", name, token, options, message)}
}

func (_c *Node_SendEvent_Call) Run(run func(name gen.Atom, token gen.Ref, options gen.MessageOptions, message any)) *Node_SendEvent_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(gen.Atom), args[1].(gen.Ref), args[2].(gen.MessageOptions), args[3].(any))
	})
	return _c
}

func (_c *Node_SendEvent_Call) Return(err error) *Node_SendEvent_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *Node_SendEvent_Call) RunAndReturn(run func(name gen.Atom, token gen.Ref, options gen.MessageOptions, message any) error) *Node_SendEvent_Call {
	_c.Call.Return(run)
	return _c
}

// SendExit provides a mock function for the type Node
func (_mock *Node) SendExit(pid gen.PID, reason error) error {
	ret := _mock.Called(pid, reason)

	if len(ret) == 0 {
		panic("no return value specified for SendExit")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(gen.PID, error) error); ok {
		r0 = returnFunc(pid, reason)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// Node_SendExit_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SendExit'
type Node_SendExit_Call struct {
	*mock.Call
}

// SendExit is a helper method to define mock.On call
//   - pid
//   - reason
func (_e *Node_Expecter) SendExit(pid interface{}, reason interface{}) *Node_SendExit_Call {
	return &Node_SendExit_Call{Call: _e.mock.On("SendExit", pid, reason)}
}

func (_c *Node_SendExit_Call) Run(run func(pid gen.PID, reason error)) *Node_SendExit_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(gen.PID), args[1].(error))
	})
	return _c
}

func (_c *Node_SendExit_Call) Return(err error) *Node_SendExit_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *Node_SendExit_Call) RunAndReturn(run func(pid gen.PID, reason error) error) *Node_SendExit_Call {
	_c.Call.Return(run)
	return _c
}

// SendWithPriority provides a mock function for the type Node
func (_mock *Node) SendWithPriority(to any, message any, priority gen.MessagePriority) error {
	ret := _mock.Called(to, message, priority)

	if len(ret) == 0 {
		panic("no return value specified for SendWithPriority")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(any, any, gen.MessagePriority) error); ok {
		r0 = returnFunc(to, message, priority)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// Node_SendWithPriority_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SendWithPriority'
type Node_SendWithPriority_Call struct {
	*mock.Call
}

// SendWithPriority is a helper method to define mock.On call
//   - to
//   - message
//   - priority
func (_e *Node_Expecter) SendWithPriority(to interface{}, message interface{}, priority interface{}) *Node_SendWithPriority_Call {
	return &Node_SendWithPriority_Call{Call: _e.mock.On("SendWithPriority", to, message, priority)}
}

func (_c *Node_SendWithPriority_Call) Run(run func(to any, message any, priority gen.MessagePriority)) *Node_SendWithPriority_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(any), args[1].(any), args[2].(gen.MessagePriority))
	})
	return _c
}

func (_c *Node_SendWithPriority_Call) Return(err error) *Node_SendWithPriority_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *Node_SendWithPriority_Call) RunAndReturn(run func(to any, message any, priority gen.MessagePriority) error) *Node_SendWithPriority_Call {
	_c.Call.Return(run)
	return _c
}

// SetCTRLC provides a mock function for the type Node
func (_mock *Node) SetCTRLC(enable bool) {
	_mock.Called(enable)
	return
}

// Node_SetCTRLC_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetCTRLC'
type Node_SetCTRLC_Call struct {
	*mock.Call
}

// SetCTRLC is a helper method to define mock.On call
//   - enable
func (_e *Node_Expecter) SetCTRLC(enable interface{}) *Node_SetCTRLC_Call {
	return &Node_SetCTRLC_Call{Call: _e.mock.On("SetCTRLC", enable)}
}

func (_c *Node_SetCTRLC_Call) Run(run func(enable bool)) *Node_SetCTRLC_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(bool))
	})
	return _c
}

func (_c *Node_SetCTRLC_Call) Return() *Node_SetCTRLC_Call {
	_c.Call.Return()
	return _c
}

func (_c *Node_SetCTRLC_Call) RunAndReturn(run func(enable bool)) *Node_SetCTRLC_Call {
	_c.Run(run)
	return _c
}

// SetEnv provides a mock function for the type Node
func (_mock *Node) SetEnv(name gen.Env, value any) {
	_mock.Called(name, value)
	return
}

// Node_SetEnv_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetEnv'
type Node_SetEnv_Call struct {
	*mock.Call
}

// SetEnv is a helper method to define mock.On call
//   - name
//   - value
func (_e *Node_Expecter) SetEnv(name interface{}, value interface{}) *Node_SetEnv_Call {
	return &Node_SetEnv_Call{Call: _e.mock.On("SetEnv", name, value)}
}

func (_c *Node_SetEnv_Call) Run(run func(name gen.Env, value any)) *Node_SetEnv_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(gen.Env), args[1].(any))
	})
	return _c
}

func (_c *Node_SetEnv_Call) Return() *Node_SetEnv_Call {
	_c.Call.Return()
	return _c
}

func (_c *Node_SetEnv_Call) RunAndReturn(run func(name gen.Env, value any)) *Node_SetEnv_Call {
	_c.Run(run)
	return _c
}

// SetLogLevelMeta provides a mock function for the type Node
func (_mock *Node) SetLogLevelMeta(meta gen.Alias, level gen.LogLevel) error {
	ret := _mock.Called(meta, level)

	if len(ret) == 0 {
		panic("no return value specified for SetLogLevelMeta")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(gen.Alias, gen.LogLevel) error); ok {
		r0 = returnFunc(meta, level)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// Node_SetLogLevelMeta_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetLogLevelMeta'
type Node_SetLogLevelMeta_Call struct {
	*mock.Call
}

// SetLogLevelMeta is a helper method to define mock.On call
//   - meta
//   - level
func (_e *Node_Expecter) SetLogLevelMeta(meta interface{}, level interface{}) *Node_SetLogLevelMeta_Call {
	return &Node_SetLogLevelMeta_Call{Call: _e.mock.On("SetLogLevelMeta", meta, level)}
}

func (_c *Node_SetLogLevelMeta_Call) Run(run func(meta gen.Alias, level gen.LogLevel)) *Node_SetLogLevelMeta_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(gen.Alias), args[1].(gen.LogLevel))
	})
	return _c
}

func (_c *Node_SetLogLevelMeta_Call) Return(err error) *Node_SetLogLevelMeta_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *Node_SetLogLevelMeta_Call) RunAndReturn(run func(meta gen.Alias, level gen.LogLevel) error) *Node_SetLogLevelMeta_Call {
	_c.Call.Return(run)
	return _c
}

// SetLogLevelProcess provides a mock function for the type Node
func (_mock *Node) SetLogLevelProcess(pid gen.PID, level gen.LogLevel) error {
	ret := _mock.Called(pid, level)

	if len(ret) == 0 {
		panic("no return value specified for SetLogLevelProcess")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(gen.PID, gen.LogLevel) error); ok {
		r0 = returnFunc(pid, level)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// Node_SetLogLevelProcess_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetLogLevelProcess'
type Node_SetLogLevelProcess_Call struct {
	*mock.Call
}

// SetLogLevelProcess is a helper method to define mock.On call
//   - pid
//   - level
func (_e *Node_Expecter) SetLogLevelProcess(pid interface{}, level interface{}) *Node_SetLogLevelProcess_Call {
	return &Node_SetLogLevelProcess_Call{Call: _e.mock.On("SetLogLevelProcess", pid, level)}
}

func (_c *Node_SetLogLevelProcess_Call) Run(run func(pid gen.PID, level gen.LogLevel)) *Node_SetLogLevelProcess_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(gen.PID), args[1].(gen.LogLevel))
	})
	return _c
}

func (_c *Node_SetLogLevelProcess_Call) Return(err error) *Node_SetLogLevelProcess_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *Node_SetLogLevelProcess_Call) RunAndReturn(run func(pid gen.PID, level gen.LogLevel) error) *Node_SetLogLevelProcess_Call {
	_c.Call.Return(run)
	return _c
}

// Spawn provides a mock function for the type Node
func (_mock *Node) Spawn(factory gen.ProcessFactory, options gen.ProcessOptions, args ...any) (gen.PID, error) {
	var tmpRet mock.Arguments
	if len(args) > 0 {
		tmpRet = _mock.Called(factory, options, args)
	} else {
		tmpRet = _mock.Called(factory, options)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for Spawn")
	}

	var r0 gen.PID
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(gen.ProcessFactory, gen.ProcessOptions, ...any) (gen.PID, error)); ok {
		return returnFunc(factory, options, args...)
	}
	if returnFunc, ok := ret.Get(0).(func(gen.ProcessFactory, gen.ProcessOptions, ...any) gen.PID); ok {
		r0 = returnFunc(factory, options, args...)
	} else {
		r0 = ret.Get(0).(gen.PID)
	}
	if returnFunc, ok := ret.Get(1).(func(gen.ProcessFactory, gen.ProcessOptions, ...any) error); ok {
		r1 = returnFunc(factory, options, args...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Node_Spawn_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Spawn'
type Node_Spawn_Call struct {
	*mock.Call
}

// Spawn is a helper method to define mock.On call
//   - factory
//   - options
//   - args
func (_e *Node_Expecter) Spawn(factory interface{}, options interface{}, args ...interface{}) *Node_Spawn_Call {
	return &Node_Spawn_Call{Call: _e.mock.On("Spawn",
		append([]interface{}{factory, options}, args...)...)}
}

func (_c *Node_Spawn_Call) Run(run func(factory gen.ProcessFactory, options gen.ProcessOptions, args ...any)) *Node_Spawn_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := args[2].([]any)
		run(args[0].(gen.ProcessFactory), args[1].(gen.ProcessOptions), variadicArgs...)
	})
	return _c
}

func (_c *Node_Spawn_Call) Return(pID gen.PID, err error) *Node_Spawn_Call {
	_c.Call.Return(pID, err)
	return _c
}

func (_c *Node_Spawn_Call) RunAndReturn(run func(factory gen.ProcessFactory, options gen.ProcessOptions, args ...any) (gen.PID, error)) *Node_Spawn_Call {
	_c.Call.Return(run)
	return _c
}

// SpawnRegister provides a mock function for the type Node
func (_mock *Node) SpawnRegister(register gen.Atom, factory gen.ProcessFactory, options gen.ProcessOptions, args ...any) (gen.PID, error) {
	var tmpRet mock.Arguments
	if len(args) > 0 {
		tmpRet = _mock.Called(register, factory, options, args)
	} else {
		tmpRet = _mock.Called(register, factory, options)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for SpawnRegister")
	}

	var r0 gen.PID
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(gen.Atom, gen.ProcessFactory, gen.ProcessOptions, ...any) (gen.PID, error)); ok {
		return returnFunc(register, factory, options, args...)
	}
	if returnFunc, ok := ret.Get(0).(func(gen.Atom, gen.ProcessFactory, gen.ProcessOptions, ...any) gen.PID); ok {
		r0 = returnFunc(register, factory, options, args...)
	} else {
		r0 = ret.Get(0).(gen.PID)
	}
	if returnFunc, ok := ret.Get(1).(func(gen.Atom, gen.ProcessFactory, gen.ProcessOptions, ...any) error); ok {
		r1 = returnFunc(register, factory, options, args...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Node_SpawnRegister_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SpawnRegister'
type Node_SpawnRegister_Call struct {
	*mock.Call
}

// SpawnRegister is a helper method to define mock.On call
//   - register
//   - factory
//   - options
//   - args
func (_e *Node_Expecter) SpawnRegister(register interface{}, factory interface{}, options interface{}, args ...interface{}) *Node_SpawnRegister_Call {
	return &Node_SpawnRegister_Call{Call: _e.mock.On("SpawnRegister",
		append([]interface{}{register, factory, options}, args...)...)}
}

func (_c *Node_SpawnRegister_Call) Run(run func(register gen.Atom, factory gen.ProcessFactory, options gen.ProcessOptions, args ...any)) *Node_SpawnRegister_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := args[3].([]any)
		run(args[0].(gen.Atom), args[1].(gen.ProcessFactory), args[2].(gen.ProcessOptions), variadicArgs...)
	})
	return _c
}

func (_c *Node_SpawnRegister_Call) Return(pID gen.PID, err error) *Node_SpawnRegister_Call {
	_c.Call.Return(pID, err)
	return _c
}

func (_c *Node_SpawnRegister_Call) RunAndReturn(run func(register gen.Atom, factory gen.ProcessFactory, options gen.ProcessOptions, args ...any) (gen.PID, error)) *Node_SpawnRegister_Call {
	_c.Call.Return(run)
	return _c
}

// Stop provides a mock function for the type Node
func (_mock *Node) Stop() {
	_mock.Called()
	return
}

// Node_Stop_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Stop'
type Node_Stop_Call struct {
	*mock.Call
}

// Stop is a helper method to define mock.On call
func (_e *Node_Expecter) Stop() *Node_Stop_Call {
	return &Node_Stop_Call{Call: _e.mock.On("Stop")}
}

func (_c *Node_Stop_Call) Run(run func()) *Node_Stop_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Node_Stop_Call) Return() *Node_Stop_Call {
	_c.Call.Return()
	return _c
}

func (_c *Node_Stop_Call) RunAndReturn(run func()) *Node_Stop_Call {
	_c.Run(run)
	return _c
}

// StopForce provides a mock function for the type Node
func (_mock *Node) StopForce() {
	_mock.Called()
	return
}

// Node_StopForce_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StopForce'
type Node_StopForce_Call struct {
	*mock.Call
}

// StopForce is a helper method to define mock.On call
func (_e *Node_Expecter) StopForce() *Node_StopForce_Call {
	return &Node_StopForce_Call{Call: _e.mock.On("StopForce")}
}

func (_c *Node_StopForce_Call) Run(run func()) *Node_StopForce_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Node_StopForce_Call) Return() *Node_StopForce_Call {
	_c.Call.Return()
	return _c
}

func (_c *Node_StopForce_Call) RunAndReturn(run func()) *Node_StopForce_Call {
	_c.Run(run)
	return _c
}

// UnregisterEvent provides a mock function for the type Node
func (_mock *Node) UnregisterEvent(name gen.Atom) error {
	ret := _mock.Called(name)

	if len(ret) == 0 {
		panic("no return value specified for UnregisterEvent")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(gen.Atom) error); ok {
		r0 = returnFunc(name)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// Node_UnregisterEvent_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UnregisterEvent'
type Node_UnregisterEvent_Call struct {
	*mock.Call
}

// UnregisterEvent is a helper method to define mock.On call
//   - name
func (_e *Node_Expecter) UnregisterEvent(name interface{}) *Node_UnregisterEvent_Call {
	return &Node_UnregisterEvent_Call{Call: _e.mock.On("UnregisterEvent", name)}
}

func (_c *Node_UnregisterEvent_Call) Run(run func(name gen.Atom)) *Node_UnregisterEvent_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(gen.Atom))
	})
	return _c
}

func (_c *Node_UnregisterEvent_Call) Return(err error) *Node_UnregisterEvent_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *Node_UnregisterEvent_Call) RunAndReturn(run func(name gen.Atom) error) *Node_UnregisterEvent_Call {
	_c.Call.Return(run)
	return _c
}

// UnregisterName provides a mock function for the type Node
func (_mock *Node) UnregisterName(name gen.Atom) (gen.PID, error) {
	ret := _mock.Called(name)

	if len(ret) == 0 {
		panic("no return value specified for UnregisterName")
	}

	var r0 gen.PID
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(gen.Atom) (gen.PID, error)); ok {
		return returnFunc(name)
	}
	if returnFunc, ok := ret.Get(0).(func(gen.Atom) gen.PID); ok {
		r0 = returnFunc(name)
	} else {
		r0 = ret.Get(0).(gen.PID)
	}
	if returnFunc, ok := ret.Get(1).(func(gen.Atom) error); ok {
		r1 = returnFunc(name)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Node_UnregisterName_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UnregisterName'
type Node_UnregisterName_Call struct {
	*mock.Call
}

// UnregisterName is a helper method to define mock.On call
//   - name
func (_e *Node_Expecter) UnregisterName(name interface{}) *Node_UnregisterName_Call {
	return &Node_UnregisterName_Call{Call: _e.mock.On("UnregisterName", name)}
}

func (_c *Node_UnregisterName_Call) Run(run func(name gen.Atom)) *Node_UnregisterName_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(gen.Atom))
	})
	return _c
}

func (_c *Node_UnregisterName_Call) Return(pID gen.PID, err error) *Node_UnregisterName_Call {
	_c.Call.Return(pID, err)
	return _c
}

func (_c *Node_UnregisterName_Call) RunAndReturn(run func(name gen.Atom) (gen.PID, error)) *Node_UnregisterName_Call {
	_c.Call.Return(run)
	return _c
}

// Uptime provides a mock function for the type Node
func (_mock *Node) Uptime() int64 {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Uptime")
	}

	var r0 int64
	if returnFunc, ok := ret.Get(0).(func() int64); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(int64)
	}
	return r0
}

// Node_Uptime_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Uptime'
type Node_Uptime_Call struct {
	*mock.Call
}

// Uptime is a helper method to define mock.On call
func (_e *Node_Expecter) Uptime() *Node_Uptime_Call {
	return &Node_Uptime_Call{Call: _e.mock.On("Uptime")}
}

func (_c *Node_Uptime_Call) Run(run func()) *Node_Uptime_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Node_Uptime_Call) Return(n int64) *Node_Uptime_Call {
	_c.Call.Return(n)
	return _c
}

func (_c *Node_Uptime_Call) RunAndReturn(run func() int64) *Node_Uptime_Call {
	_c.Call.Return(run)
	return _c
}

// Version provides a mock function for the type Node
func (_mock *Node) Version() gen.Version {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Version")
	}

	var r0 gen.Version
	if returnFunc, ok := ret.Get(0).(func() gen.Version); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(gen.Version)
	}
	return r0
}

// Node_Version_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Version'
type Node_Version_Call struct {
	*mock.Call
}

// Version is a helper method to define mock.On call
func (_e *Node_Expecter) Version() *Node_Version_Call {
	return &Node_Version_Call{Call: _e.mock.On("Version")}
}

func (_c *Node_Version_Call) Run(run func()) *Node_Version_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Node_Version_Call) Return(version gen.Version) *Node_Version_Call {
	_c.Call.Return(version)
	return _c
}

func (_c *Node_Version_Call) RunAndReturn(run func() gen.Version) *Node_Version_Call {
	_c.Call.Return(run)
	return _c
}

// Wait provides a mock function for the type Node
func (_mock *Node) Wait() {
	_mock.Called()
	return
}

// Node_Wait_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Wait'
type Node_Wait_Call struct {
	*mock.Call
}

// Wait is a helper method to define mock.On call
func (_e *Node_Expecter) Wait() *Node_Wait_Call {
	return &Node_Wait_Call{Call: _e.mock.On("Wait")}
}

func (_c *Node_Wait_Call) Run(run func()) *Node_Wait_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Node_Wait_Call) Return() *Node_Wait_Call {
	_c.Call.Return()
	return _c
}

func (_c *Node_Wait_Call) RunAndReturn(run func()) *Node_Wait_Call {
	_c.Run(run)
	return _c
}

// WaitWithTimeout provides a mock function for the type Node
func (_mock *Node) WaitWithTimeout(timeout time.Duration) error {
	ret := _mock.Called(timeout)

	if len(ret) == 0 {
		panic("no return value specified for WaitWithTimeout")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(time.Duration) error); ok {
		r0 = returnFunc(timeout)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// Node_WaitWithTimeout_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WaitWithTimeout'
type Node_WaitWithTimeout_Call struct {
	*mock.Call
}

// WaitWithTimeout is a helper method to define mock.On call
//   - timeout
func (_e *Node_Expecter) WaitWithTimeout(timeout interface{}) *Node_WaitWithTimeout_Call {
	return &Node_WaitWithTimeout_Call{Call: _e.mock.On("WaitWithTimeout", timeout)}
}

func (_c *Node_WaitWithTimeout_Call) Run(run func(timeout time.Duration)) *Node_WaitWithTimeout_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(time.Duration))
	})
	return _c
}

func (_c *Node_WaitWithTimeout_Call) Return(err error) *Node_WaitWithTimeout_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *Node_WaitWithTimeout_Call) RunAndReturn(run func(timeout time.Duration) error) *Node_WaitWithTimeout_Call {
	_c.Call.Return(run)
	return _c
}
