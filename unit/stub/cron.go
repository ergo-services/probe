// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery
// template: testify

package stub

import (
	"time"

	"ergo.services/ergo/gen"
	mock "github.com/stretchr/testify/mock"
)

// NewCron creates a new instance of Cron. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewCron(t interface {
	mock.TestingT
	Cleanup(func())
}) *Cron {
	mock := &Cron{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// Cron is an autogenerated mock type for the Cron type
type Cron struct {
	mock.Mock
}

type Cron_Expecter struct {
	mock *mock.Mock
}

func (_m *Cron) EXPECT() *Cron_Expecter {
	return &Cron_Expecter{mock: &_m.Mock}
}

// AddJob provides a mock function for the type Cron
func (_mock *Cron) AddJob(job gen.CronJob) error {
	ret := _mock.Called(job)

	if len(ret) == 0 {
		panic("no return value specified for AddJob")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(gen.CronJob) error); ok {
		r0 = returnFunc(job)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// Cron_AddJob_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddJob'
type Cron_AddJob_Call struct {
	*mock.Call
}

// AddJob is a helper method to define mock.On call
//   - job
func (_e *Cron_Expecter) AddJob(job interface{}) *Cron_AddJob_Call {
	return &Cron_AddJob_Call{Call: _e.mock.On("AddJob", job)}
}

func (_c *Cron_AddJob_Call) Run(run func(job gen.CronJob)) *Cron_AddJob_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(gen.CronJob))
	})
	return _c
}

func (_c *Cron_AddJob_Call) Return(err error) *Cron_AddJob_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *Cron_AddJob_Call) RunAndReturn(run func(job gen.CronJob) error) *Cron_AddJob_Call {
	_c.Call.Return(run)
	return _c
}

// DisableJob provides a mock function for the type Cron
func (_mock *Cron) DisableJob(name gen.Atom) error {
	ret := _mock.Called(name)

	if len(ret) == 0 {
		panic("no return value specified for DisableJob")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(gen.Atom) error); ok {
		r0 = returnFunc(name)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// Cron_DisableJob_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DisableJob'
type Cron_DisableJob_Call struct {
	*mock.Call
}

// DisableJob is a helper method to define mock.On call
//   - name
func (_e *Cron_Expecter) DisableJob(name interface{}) *Cron_DisableJob_Call {
	return &Cron_DisableJob_Call{Call: _e.mock.On("DisableJob", name)}
}

func (_c *Cron_DisableJob_Call) Run(run func(name gen.Atom)) *Cron_DisableJob_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(gen.Atom))
	})
	return _c
}

func (_c *Cron_DisableJob_Call) Return(err error) *Cron_DisableJob_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *Cron_DisableJob_Call) RunAndReturn(run func(name gen.Atom) error) *Cron_DisableJob_Call {
	_c.Call.Return(run)
	return _c
}

// EnableJob provides a mock function for the type Cron
func (_mock *Cron) EnableJob(name gen.Atom) error {
	ret := _mock.Called(name)

	if len(ret) == 0 {
		panic("no return value specified for EnableJob")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(gen.Atom) error); ok {
		r0 = returnFunc(name)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// Cron_EnableJob_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'EnableJob'
type Cron_EnableJob_Call struct {
	*mock.Call
}

// EnableJob is a helper method to define mock.On call
//   - name
func (_e *Cron_Expecter) EnableJob(name interface{}) *Cron_EnableJob_Call {
	return &Cron_EnableJob_Call{Call: _e.mock.On("EnableJob", name)}
}

func (_c *Cron_EnableJob_Call) Run(run func(name gen.Atom)) *Cron_EnableJob_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(gen.Atom))
	})
	return _c
}

func (_c *Cron_EnableJob_Call) Return(err error) *Cron_EnableJob_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *Cron_EnableJob_Call) RunAndReturn(run func(name gen.Atom) error) *Cron_EnableJob_Call {
	_c.Call.Return(run)
	return _c
}

// Info provides a mock function for the type Cron
func (_mock *Cron) Info() gen.CronInfo {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Info")
	}

	var r0 gen.CronInfo
	if returnFunc, ok := ret.Get(0).(func() gen.CronInfo); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(gen.CronInfo)
	}
	return r0
}

// Cron_Info_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Info'
type Cron_Info_Call struct {
	*mock.Call
}

// Info is a helper method to define mock.On call
func (_e *Cron_Expecter) Info() *Cron_Info_Call {
	return &Cron_Info_Call{Call: _e.mock.On("Info")}
}

func (_c *Cron_Info_Call) Run(run func()) *Cron_Info_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Cron_Info_Call) Return(cronInfo gen.CronInfo) *Cron_Info_Call {
	_c.Call.Return(cronInfo)
	return _c
}

func (_c *Cron_Info_Call) RunAndReturn(run func() gen.CronInfo) *Cron_Info_Call {
	_c.Call.Return(run)
	return _c
}

// JobInfo provides a mock function for the type Cron
func (_mock *Cron) JobInfo(name gen.Atom) (gen.CronJobInfo, error) {
	ret := _mock.Called(name)

	if len(ret) == 0 {
		panic("no return value specified for JobInfo")
	}

	var r0 gen.CronJobInfo
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(gen.Atom) (gen.CronJobInfo, error)); ok {
		return returnFunc(name)
	}
	if returnFunc, ok := ret.Get(0).(func(gen.Atom) gen.CronJobInfo); ok {
		r0 = returnFunc(name)
	} else {
		r0 = ret.Get(0).(gen.CronJobInfo)
	}
	if returnFunc, ok := ret.Get(1).(func(gen.Atom) error); ok {
		r1 = returnFunc(name)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Cron_JobInfo_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'JobInfo'
type Cron_JobInfo_Call struct {
	*mock.Call
}

// JobInfo is a helper method to define mock.On call
//   - name
func (_e *Cron_Expecter) JobInfo(name interface{}) *Cron_JobInfo_Call {
	return &Cron_JobInfo_Call{Call: _e.mock.On("JobInfo", name)}
}

func (_c *Cron_JobInfo_Call) Run(run func(name gen.Atom)) *Cron_JobInfo_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(gen.Atom))
	})
	return _c
}

func (_c *Cron_JobInfo_Call) Return(cronJobInfo gen.CronJobInfo, err error) *Cron_JobInfo_Call {
	_c.Call.Return(cronJobInfo, err)
	return _c
}

func (_c *Cron_JobInfo_Call) RunAndReturn(run func(name gen.Atom) (gen.CronJobInfo, error)) *Cron_JobInfo_Call {
	_c.Call.Return(run)
	return _c
}

// JobSchedule provides a mock function for the type Cron
func (_mock *Cron) JobSchedule(job gen.Atom, since time.Time, duration time.Duration) ([]time.Time, error) {
	ret := _mock.Called(job, since, duration)

	if len(ret) == 0 {
		panic("no return value specified for JobSchedule")
	}

	var r0 []time.Time
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(gen.Atom, time.Time, time.Duration) ([]time.Time, error)); ok {
		return returnFunc(job, since, duration)
	}
	if returnFunc, ok := ret.Get(0).(func(gen.Atom, time.Time, time.Duration) []time.Time); ok {
		r0 = returnFunc(job, since, duration)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]time.Time)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(gen.Atom, time.Time, time.Duration) error); ok {
		r1 = returnFunc(job, since, duration)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Cron_JobSchedule_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'JobSchedule'
type Cron_JobSchedule_Call struct {
	*mock.Call
}

// JobSchedule is a helper method to define mock.On call
//   - job
//   - since
//   - duration
func (_e *Cron_Expecter) JobSchedule(job interface{}, since interface{}, duration interface{}) *Cron_JobSchedule_Call {
	return &Cron_JobSchedule_Call{Call: _e.mock.On("JobSchedule", job, since, duration)}
}

func (_c *Cron_JobSchedule_Call) Run(run func(job gen.Atom, since time.Time, duration time.Duration)) *Cron_JobSchedule_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(gen.Atom), args[1].(time.Time), args[2].(time.Duration))
	})
	return _c
}

func (_c *Cron_JobSchedule_Call) Return(times []time.Time, err error) *Cron_JobSchedule_Call {
	_c.Call.Return(times, err)
	return _c
}

func (_c *Cron_JobSchedule_Call) RunAndReturn(run func(job gen.Atom, since time.Time, duration time.Duration) ([]time.Time, error)) *Cron_JobSchedule_Call {
	_c.Call.Return(run)
	return _c
}

// RemoveJob provides a mock function for the type Cron
func (_mock *Cron) RemoveJob(name gen.Atom) error {
	ret := _mock.Called(name)

	if len(ret) == 0 {
		panic("no return value specified for RemoveJob")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(gen.Atom) error); ok {
		r0 = returnFunc(name)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// Cron_RemoveJob_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RemoveJob'
type Cron_RemoveJob_Call struct {
	*mock.Call
}

// RemoveJob is a helper method to define mock.On call
//   - name
func (_e *Cron_Expecter) RemoveJob(name interface{}) *Cron_RemoveJob_Call {
	return &Cron_RemoveJob_Call{Call: _e.mock.On("RemoveJob", name)}
}

func (_c *Cron_RemoveJob_Call) Run(run func(name gen.Atom)) *Cron_RemoveJob_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(gen.Atom))
	})
	return _c
}

func (_c *Cron_RemoveJob_Call) Return(err error) *Cron_RemoveJob_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *Cron_RemoveJob_Call) RunAndReturn(run func(name gen.Atom) error) *Cron_RemoveJob_Call {
	_c.Call.Return(run)
	return _c
}

// Schedule provides a mock function for the type Cron
func (_mock *Cron) Schedule(since time.Time, duration time.Duration) []gen.CronSchedule {
	ret := _mock.Called(since, duration)

	if len(ret) == 0 {
		panic("no return value specified for Schedule")
	}

	var r0 []gen.CronSchedule
	if returnFunc, ok := ret.Get(0).(func(time.Time, time.Duration) []gen.CronSchedule); ok {
		r0 = returnFunc(since, duration)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]gen.CronSchedule)
		}
	}
	return r0
}

// Cron_Schedule_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Schedule'
type Cron_Schedule_Call struct {
	*mock.Call
}

// Schedule is a helper method to define mock.On call
//   - since
//   - duration
func (_e *Cron_Expecter) Schedule(since interface{}, duration interface{}) *Cron_Schedule_Call {
	return &Cron_Schedule_Call{Call: _e.mock.On("Schedule", since, duration)}
}

func (_c *Cron_Schedule_Call) Run(run func(since time.Time, duration time.Duration)) *Cron_Schedule_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(time.Time), args[1].(time.Duration))
	})
	return _c
}

func (_c *Cron_Schedule_Call) Return(cronSchedules []gen.CronSchedule) *Cron_Schedule_Call {
	_c.Call.Return(cronSchedules)
	return _c
}

func (_c *Cron_Schedule_Call) RunAndReturn(run func(since time.Time, duration time.Duration) []gen.CronSchedule) *Cron_Schedule_Call {
	_c.Call.Return(run)
	return _c
}
