// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery
// template: testify

package stub

import (
	"ergo.services/ergo/gen"
	mock "github.com/stretchr/testify/mock"
)

// NewNetwork creates a new instance of Network. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewNetwork(t interface {
	mock.TestingT
	Cleanup(func())
}) *Network {
	mock := &Network{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// Network is an autogenerated mock type for the Network type
type Network struct {
	mock.Mock
}

type Network_Expecter struct {
	mock *mock.Mock
}

func (_m *Network) EXPECT() *Network_Expecter {
	return &Network_Expecter{mock: &_m.Mock}
}

// Acceptors provides a mock function for the type Network
func (_mock *Network) Acceptors() ([]gen.Acceptor, error) {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Acceptors")
	}

	var r0 []gen.Acceptor
	var r1 error
	if returnFunc, ok := ret.Get(0).(func() ([]gen.Acceptor, error)); ok {
		return returnFunc()
	}
	if returnFunc, ok := ret.Get(0).(func() []gen.Acceptor); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]gen.Acceptor)
		}
	}
	if returnFunc, ok := ret.Get(1).(func() error); ok {
		r1 = returnFunc()
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Network_Acceptors_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Acceptors'
type Network_Acceptors_Call struct {
	*mock.Call
}

// Acceptors is a helper method to define mock.On call
func (_e *Network_Expecter) Acceptors() *Network_Acceptors_Call {
	return &Network_Acceptors_Call{Call: _e.mock.On("Acceptors")}
}

func (_c *Network_Acceptors_Call) Run(run func()) *Network_Acceptors_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Network_Acceptors_Call) Return(acceptors []gen.Acceptor, err error) *Network_Acceptors_Call {
	_c.Call.Return(acceptors, err)
	return _c
}

func (_c *Network_Acceptors_Call) RunAndReturn(run func() ([]gen.Acceptor, error)) *Network_Acceptors_Call {
	_c.Call.Return(run)
	return _c
}

// AddProxyRoute provides a mock function for the type Network
func (_mock *Network) AddProxyRoute(match string, proxy gen.NetworkProxyRoute, weight int) error {
	ret := _mock.Called(match, proxy, weight)

	if len(ret) == 0 {
		panic("no return value specified for AddProxyRoute")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(string, gen.NetworkProxyRoute, int) error); ok {
		r0 = returnFunc(match, proxy, weight)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// Network_AddProxyRoute_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddProxyRoute'
type Network_AddProxyRoute_Call struct {
	*mock.Call
}

// AddProxyRoute is a helper method to define mock.On call
//   - match
//   - proxy
//   - weight
func (_e *Network_Expecter) AddProxyRoute(match interface{}, proxy interface{}, weight interface{}) *Network_AddProxyRoute_Call {
	return &Network_AddProxyRoute_Call{Call: _e.mock.On("AddProxyRoute", match, proxy, weight)}
}

func (_c *Network_AddProxyRoute_Call) Run(run func(match string, proxy gen.NetworkProxyRoute, weight int)) *Network_AddProxyRoute_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(gen.NetworkProxyRoute), args[2].(int))
	})
	return _c
}

func (_c *Network_AddProxyRoute_Call) Return(err error) *Network_AddProxyRoute_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *Network_AddProxyRoute_Call) RunAndReturn(run func(match string, proxy gen.NetworkProxyRoute, weight int) error) *Network_AddProxyRoute_Call {
	_c.Call.Return(run)
	return _c
}

// AddRoute provides a mock function for the type Network
func (_mock *Network) AddRoute(match string, route gen.NetworkRoute, weight int) error {
	ret := _mock.Called(match, route, weight)

	if len(ret) == 0 {
		panic("no return value specified for AddRoute")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(string, gen.NetworkRoute, int) error); ok {
		r0 = returnFunc(match, route, weight)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// Network_AddRoute_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddRoute'
type Network_AddRoute_Call struct {
	*mock.Call
}

// AddRoute is a helper method to define mock.On call
//   - match
//   - route
//   - weight
func (_e *Network_Expecter) AddRoute(match interface{}, route interface{}, weight interface{}) *Network_AddRoute_Call {
	return &Network_AddRoute_Call{Call: _e.mock.On("AddRoute", match, route, weight)}
}

func (_c *Network_AddRoute_Call) Run(run func(match string, route gen.NetworkRoute, weight int)) *Network_AddRoute_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(gen.NetworkRoute), args[2].(int))
	})
	return _c
}

func (_c *Network_AddRoute_Call) Return(err error) *Network_AddRoute_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *Network_AddRoute_Call) RunAndReturn(run func(match string, route gen.NetworkRoute, weight int) error) *Network_AddRoute_Call {
	_c.Call.Return(run)
	return _c
}

// Cookie provides a mock function for the type Network
func (_mock *Network) Cookie() string {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Cookie")
	}

	var r0 string
	if returnFunc, ok := ret.Get(0).(func() string); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(string)
	}
	return r0
}

// Network_Cookie_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Cookie'
type Network_Cookie_Call struct {
	*mock.Call
}

// Cookie is a helper method to define mock.On call
func (_e *Network_Expecter) Cookie() *Network_Cookie_Call {
	return &Network_Cookie_Call{Call: _e.mock.On("Cookie")}
}

func (_c *Network_Cookie_Call) Run(run func()) *Network_Cookie_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Network_Cookie_Call) Return(s string) *Network_Cookie_Call {
	_c.Call.Return(s)
	return _c
}

func (_c *Network_Cookie_Call) RunAndReturn(run func() string) *Network_Cookie_Call {
	_c.Call.Return(run)
	return _c
}

// DisableApplicationStart provides a mock function for the type Network
func (_mock *Network) DisableApplicationStart(name gen.Atom, nodes ...gen.Atom) error {
	var tmpRet mock.Arguments
	if len(nodes) > 0 {
		tmpRet = _mock.Called(name, nodes)
	} else {
		tmpRet = _mock.Called(name)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for DisableApplicationStart")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(gen.Atom, ...gen.Atom) error); ok {
		r0 = returnFunc(name, nodes...)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// Network_DisableApplicationStart_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DisableApplicationStart'
type Network_DisableApplicationStart_Call struct {
	*mock.Call
}

// DisableApplicationStart is a helper method to define mock.On call
//   - name
//   - nodes
func (_e *Network_Expecter) DisableApplicationStart(name interface{}, nodes ...interface{}) *Network_DisableApplicationStart_Call {
	return &Network_DisableApplicationStart_Call{Call: _e.mock.On("DisableApplicationStart",
		append([]interface{}{name}, nodes...)...)}
}

func (_c *Network_DisableApplicationStart_Call) Run(run func(name gen.Atom, nodes ...gen.Atom)) *Network_DisableApplicationStart_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := args[1].([]gen.Atom)
		run(args[0].(gen.Atom), variadicArgs...)
	})
	return _c
}

func (_c *Network_DisableApplicationStart_Call) Return(err error) *Network_DisableApplicationStart_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *Network_DisableApplicationStart_Call) RunAndReturn(run func(name gen.Atom, nodes ...gen.Atom) error) *Network_DisableApplicationStart_Call {
	_c.Call.Return(run)
	return _c
}

// DisableSpawn provides a mock function for the type Network
func (_mock *Network) DisableSpawn(name gen.Atom, nodes ...gen.Atom) error {
	var tmpRet mock.Arguments
	if len(nodes) > 0 {
		tmpRet = _mock.Called(name, nodes)
	} else {
		tmpRet = _mock.Called(name)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for DisableSpawn")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(gen.Atom, ...gen.Atom) error); ok {
		r0 = returnFunc(name, nodes...)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// Network_DisableSpawn_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DisableSpawn'
type Network_DisableSpawn_Call struct {
	*mock.Call
}

// DisableSpawn is a helper method to define mock.On call
//   - name
//   - nodes
func (_e *Network_Expecter) DisableSpawn(name interface{}, nodes ...interface{}) *Network_DisableSpawn_Call {
	return &Network_DisableSpawn_Call{Call: _e.mock.On("DisableSpawn",
		append([]interface{}{name}, nodes...)...)}
}

func (_c *Network_DisableSpawn_Call) Run(run func(name gen.Atom, nodes ...gen.Atom)) *Network_DisableSpawn_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := args[1].([]gen.Atom)
		run(args[0].(gen.Atom), variadicArgs...)
	})
	return _c
}

func (_c *Network_DisableSpawn_Call) Return(err error) *Network_DisableSpawn_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *Network_DisableSpawn_Call) RunAndReturn(run func(name gen.Atom, nodes ...gen.Atom) error) *Network_DisableSpawn_Call {
	_c.Call.Return(run)
	return _c
}

// EnableApplicationStart provides a mock function for the type Network
func (_mock *Network) EnableApplicationStart(name gen.Atom, nodes ...gen.Atom) error {
	var tmpRet mock.Arguments
	if len(nodes) > 0 {
		tmpRet = _mock.Called(name, nodes)
	} else {
		tmpRet = _mock.Called(name)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for EnableApplicationStart")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(gen.Atom, ...gen.Atom) error); ok {
		r0 = returnFunc(name, nodes...)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// Network_EnableApplicationStart_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'EnableApplicationStart'
type Network_EnableApplicationStart_Call struct {
	*mock.Call
}

// EnableApplicationStart is a helper method to define mock.On call
//   - name
//   - nodes
func (_e *Network_Expecter) EnableApplicationStart(name interface{}, nodes ...interface{}) *Network_EnableApplicationStart_Call {
	return &Network_EnableApplicationStart_Call{Call: _e.mock.On("EnableApplicationStart",
		append([]interface{}{name}, nodes...)...)}
}

func (_c *Network_EnableApplicationStart_Call) Run(run func(name gen.Atom, nodes ...gen.Atom)) *Network_EnableApplicationStart_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := args[1].([]gen.Atom)
		run(args[0].(gen.Atom), variadicArgs...)
	})
	return _c
}

func (_c *Network_EnableApplicationStart_Call) Return(err error) *Network_EnableApplicationStart_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *Network_EnableApplicationStart_Call) RunAndReturn(run func(name gen.Atom, nodes ...gen.Atom) error) *Network_EnableApplicationStart_Call {
	_c.Call.Return(run)
	return _c
}

// EnableSpawn provides a mock function for the type Network
func (_mock *Network) EnableSpawn(name gen.Atom, factory gen.ProcessFactory, nodes ...gen.Atom) error {
	var tmpRet mock.Arguments
	if len(nodes) > 0 {
		tmpRet = _mock.Called(name, factory, nodes)
	} else {
		tmpRet = _mock.Called(name, factory)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for EnableSpawn")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(gen.Atom, gen.ProcessFactory, ...gen.Atom) error); ok {
		r0 = returnFunc(name, factory, nodes...)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// Network_EnableSpawn_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'EnableSpawn'
type Network_EnableSpawn_Call struct {
	*mock.Call
}

// EnableSpawn is a helper method to define mock.On call
//   - name
//   - factory
//   - nodes
func (_e *Network_Expecter) EnableSpawn(name interface{}, factory interface{}, nodes ...interface{}) *Network_EnableSpawn_Call {
	return &Network_EnableSpawn_Call{Call: _e.mock.On("EnableSpawn",
		append([]interface{}{name, factory}, nodes...)...)}
}

func (_c *Network_EnableSpawn_Call) Run(run func(name gen.Atom, factory gen.ProcessFactory, nodes ...gen.Atom)) *Network_EnableSpawn_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := args[2].([]gen.Atom)
		run(args[0].(gen.Atom), args[1].(gen.ProcessFactory), variadicArgs...)
	})
	return _c
}

func (_c *Network_EnableSpawn_Call) Return(err error) *Network_EnableSpawn_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *Network_EnableSpawn_Call) RunAndReturn(run func(name gen.Atom, factory gen.ProcessFactory, nodes ...gen.Atom) error) *Network_EnableSpawn_Call {
	_c.Call.Return(run)
	return _c
}

// GetNode provides a mock function for the type Network
func (_mock *Network) GetNode(name gen.Atom) (gen.RemoteNode, error) {
	ret := _mock.Called(name)

	if len(ret) == 0 {
		panic("no return value specified for GetNode")
	}

	var r0 gen.RemoteNode
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(gen.Atom) (gen.RemoteNode, error)); ok {
		return returnFunc(name)
	}
	if returnFunc, ok := ret.Get(0).(func(gen.Atom) gen.RemoteNode); ok {
		r0 = returnFunc(name)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(gen.RemoteNode)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(gen.Atom) error); ok {
		r1 = returnFunc(name)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Network_GetNode_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetNode'
type Network_GetNode_Call struct {
	*mock.Call
}

// GetNode is a helper method to define mock.On call
//   - name
func (_e *Network_Expecter) GetNode(name interface{}) *Network_GetNode_Call {
	return &Network_GetNode_Call{Call: _e.mock.On("GetNode", name)}
}

func (_c *Network_GetNode_Call) Run(run func(name gen.Atom)) *Network_GetNode_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(gen.Atom))
	})
	return _c
}

func (_c *Network_GetNode_Call) Return(remoteNode gen.RemoteNode, err error) *Network_GetNode_Call {
	_c.Call.Return(remoteNode, err)
	return _c
}

func (_c *Network_GetNode_Call) RunAndReturn(run func(name gen.Atom) (gen.RemoteNode, error)) *Network_GetNode_Call {
	_c.Call.Return(run)
	return _c
}

// GetNodeWithRoute provides a mock function for the type Network
func (_mock *Network) GetNodeWithRoute(name gen.Atom, route gen.NetworkRoute) (gen.RemoteNode, error) {
	ret := _mock.Called(name, route)

	if len(ret) == 0 {
		panic("no return value specified for GetNodeWithRoute")
	}

	var r0 gen.RemoteNode
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(gen.Atom, gen.NetworkRoute) (gen.RemoteNode, error)); ok {
		return returnFunc(name, route)
	}
	if returnFunc, ok := ret.Get(0).(func(gen.Atom, gen.NetworkRoute) gen.RemoteNode); ok {
		r0 = returnFunc(name, route)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(gen.RemoteNode)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(gen.Atom, gen.NetworkRoute) error); ok {
		r1 = returnFunc(name, route)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Network_GetNodeWithRoute_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetNodeWithRoute'
type Network_GetNodeWithRoute_Call struct {
	*mock.Call
}

// GetNodeWithRoute is a helper method to define mock.On call
//   - name
//   - route
func (_e *Network_Expecter) GetNodeWithRoute(name interface{}, route interface{}) *Network_GetNodeWithRoute_Call {
	return &Network_GetNodeWithRoute_Call{Call: _e.mock.On("GetNodeWithRoute", name, route)}
}

func (_c *Network_GetNodeWithRoute_Call) Run(run func(name gen.Atom, route gen.NetworkRoute)) *Network_GetNodeWithRoute_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(gen.Atom), args[1].(gen.NetworkRoute))
	})
	return _c
}

func (_c *Network_GetNodeWithRoute_Call) Return(remoteNode gen.RemoteNode, err error) *Network_GetNodeWithRoute_Call {
	_c.Call.Return(remoteNode, err)
	return _c
}

func (_c *Network_GetNodeWithRoute_Call) RunAndReturn(run func(name gen.Atom, route gen.NetworkRoute) (gen.RemoteNode, error)) *Network_GetNodeWithRoute_Call {
	_c.Call.Return(run)
	return _c
}

// Info provides a mock function for the type Network
func (_mock *Network) Info() (gen.NetworkInfo, error) {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Info")
	}

	var r0 gen.NetworkInfo
	var r1 error
	if returnFunc, ok := ret.Get(0).(func() (gen.NetworkInfo, error)); ok {
		return returnFunc()
	}
	if returnFunc, ok := ret.Get(0).(func() gen.NetworkInfo); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(gen.NetworkInfo)
	}
	if returnFunc, ok := ret.Get(1).(func() error); ok {
		r1 = returnFunc()
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Network_Info_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Info'
type Network_Info_Call struct {
	*mock.Call
}

// Info is a helper method to define mock.On call
func (_e *Network_Expecter) Info() *Network_Info_Call {
	return &Network_Info_Call{Call: _e.mock.On("Info")}
}

func (_c *Network_Info_Call) Run(run func()) *Network_Info_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Network_Info_Call) Return(networkInfo gen.NetworkInfo, err error) *Network_Info_Call {
	_c.Call.Return(networkInfo, err)
	return _c
}

func (_c *Network_Info_Call) RunAndReturn(run func() (gen.NetworkInfo, error)) *Network_Info_Call {
	_c.Call.Return(run)
	return _c
}

// MaxMessageSize provides a mock function for the type Network
func (_mock *Network) MaxMessageSize() int {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for MaxMessageSize")
	}

	var r0 int
	if returnFunc, ok := ret.Get(0).(func() int); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(int)
	}
	return r0
}

// Network_MaxMessageSize_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'MaxMessageSize'
type Network_MaxMessageSize_Call struct {
	*mock.Call
}

// MaxMessageSize is a helper method to define mock.On call
func (_e *Network_Expecter) MaxMessageSize() *Network_MaxMessageSize_Call {
	return &Network_MaxMessageSize_Call{Call: _e.mock.On("MaxMessageSize")}
}

func (_c *Network_MaxMessageSize_Call) Run(run func()) *Network_MaxMessageSize_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Network_MaxMessageSize_Call) Return(n int) *Network_MaxMessageSize_Call {
	_c.Call.Return(n)
	return _c
}

func (_c *Network_MaxMessageSize_Call) RunAndReturn(run func() int) *Network_MaxMessageSize_Call {
	_c.Call.Return(run)
	return _c
}

// Mode provides a mock function for the type Network
func (_mock *Network) Mode() gen.NetworkMode {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Mode")
	}

	var r0 gen.NetworkMode
	if returnFunc, ok := ret.Get(0).(func() gen.NetworkMode); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(gen.NetworkMode)
	}
	return r0
}

// Network_Mode_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Mode'
type Network_Mode_Call struct {
	*mock.Call
}

// Mode is a helper method to define mock.On call
func (_e *Network_Expecter) Mode() *Network_Mode_Call {
	return &Network_Mode_Call{Call: _e.mock.On("Mode")}
}

func (_c *Network_Mode_Call) Run(run func()) *Network_Mode_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Network_Mode_Call) Return(networkMode gen.NetworkMode) *Network_Mode_Call {
	_c.Call.Return(networkMode)
	return _c
}

func (_c *Network_Mode_Call) RunAndReturn(run func() gen.NetworkMode) *Network_Mode_Call {
	_c.Call.Return(run)
	return _c
}

// NetworkFlags provides a mock function for the type Network
func (_mock *Network) NetworkFlags() gen.NetworkFlags {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for NetworkFlags")
	}

	var r0 gen.NetworkFlags
	if returnFunc, ok := ret.Get(0).(func() gen.NetworkFlags); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(gen.NetworkFlags)
	}
	return r0
}

// Network_NetworkFlags_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'NetworkFlags'
type Network_NetworkFlags_Call struct {
	*mock.Call
}

// NetworkFlags is a helper method to define mock.On call
func (_e *Network_Expecter) NetworkFlags() *Network_NetworkFlags_Call {
	return &Network_NetworkFlags_Call{Call: _e.mock.On("NetworkFlags")}
}

func (_c *Network_NetworkFlags_Call) Run(run func()) *Network_NetworkFlags_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Network_NetworkFlags_Call) Return(networkFlags gen.NetworkFlags) *Network_NetworkFlags_Call {
	_c.Call.Return(networkFlags)
	return _c
}

func (_c *Network_NetworkFlags_Call) RunAndReturn(run func() gen.NetworkFlags) *Network_NetworkFlags_Call {
	_c.Call.Return(run)
	return _c
}

// Node provides a mock function for the type Network
func (_mock *Network) Node(name gen.Atom) (gen.RemoteNode, error) {
	ret := _mock.Called(name)

	if len(ret) == 0 {
		panic("no return value specified for Node")
	}

	var r0 gen.RemoteNode
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(gen.Atom) (gen.RemoteNode, error)); ok {
		return returnFunc(name)
	}
	if returnFunc, ok := ret.Get(0).(func(gen.Atom) gen.RemoteNode); ok {
		r0 = returnFunc(name)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(gen.RemoteNode)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(gen.Atom) error); ok {
		r1 = returnFunc(name)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Network_Node_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Node'
type Network_Node_Call struct {
	*mock.Call
}

// Node is a helper method to define mock.On call
//   - name
func (_e *Network_Expecter) Node(name interface{}) *Network_Node_Call {
	return &Network_Node_Call{Call: _e.mock.On("Node", name)}
}

func (_c *Network_Node_Call) Run(run func(name gen.Atom)) *Network_Node_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(gen.Atom))
	})
	return _c
}

func (_c *Network_Node_Call) Return(remoteNode gen.RemoteNode, err error) *Network_Node_Call {
	_c.Call.Return(remoteNode, err)
	return _c
}

func (_c *Network_Node_Call) RunAndReturn(run func(name gen.Atom) (gen.RemoteNode, error)) *Network_Node_Call {
	_c.Call.Return(run)
	return _c
}

// Nodes provides a mock function for the type Network
func (_mock *Network) Nodes() []gen.Atom {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Nodes")
	}

	var r0 []gen.Atom
	if returnFunc, ok := ret.Get(0).(func() []gen.Atom); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]gen.Atom)
		}
	}
	return r0
}

// Network_Nodes_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Nodes'
type Network_Nodes_Call struct {
	*mock.Call
}

// Nodes is a helper method to define mock.On call
func (_e *Network_Expecter) Nodes() *Network_Nodes_Call {
	return &Network_Nodes_Call{Call: _e.mock.On("Nodes")}
}

func (_c *Network_Nodes_Call) Run(run func()) *Network_Nodes_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Network_Nodes_Call) Return(atoms []gen.Atom) *Network_Nodes_Call {
	_c.Call.Return(atoms)
	return _c
}

func (_c *Network_Nodes_Call) RunAndReturn(run func() []gen.Atom) *Network_Nodes_Call {
	_c.Call.Return(run)
	return _c
}

// ProxyRoute provides a mock function for the type Network
func (_mock *Network) ProxyRoute(name gen.Atom) ([]gen.NetworkProxyRoute, error) {
	ret := _mock.Called(name)

	if len(ret) == 0 {
		panic("no return value specified for ProxyRoute")
	}

	var r0 []gen.NetworkProxyRoute
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(gen.Atom) ([]gen.NetworkProxyRoute, error)); ok {
		return returnFunc(name)
	}
	if returnFunc, ok := ret.Get(0).(func(gen.Atom) []gen.NetworkProxyRoute); ok {
		r0 = returnFunc(name)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]gen.NetworkProxyRoute)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(gen.Atom) error); ok {
		r1 = returnFunc(name)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Network_ProxyRoute_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ProxyRoute'
type Network_ProxyRoute_Call struct {
	*mock.Call
}

// ProxyRoute is a helper method to define mock.On call
//   - name
func (_e *Network_Expecter) ProxyRoute(name interface{}) *Network_ProxyRoute_Call {
	return &Network_ProxyRoute_Call{Call: _e.mock.On("ProxyRoute", name)}
}

func (_c *Network_ProxyRoute_Call) Run(run func(name gen.Atom)) *Network_ProxyRoute_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(gen.Atom))
	})
	return _c
}

func (_c *Network_ProxyRoute_Call) Return(networkProxyRoutes []gen.NetworkProxyRoute, err error) *Network_ProxyRoute_Call {
	_c.Call.Return(networkProxyRoutes, err)
	return _c
}

func (_c *Network_ProxyRoute_Call) RunAndReturn(run func(name gen.Atom) ([]gen.NetworkProxyRoute, error)) *Network_ProxyRoute_Call {
	_c.Call.Return(run)
	return _c
}

// RegisterHandshake provides a mock function for the type Network
func (_mock *Network) RegisterHandshake(handshake gen.NetworkHandshake) {
	_mock.Called(handshake)
	return
}

// Network_RegisterHandshake_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RegisterHandshake'
type Network_RegisterHandshake_Call struct {
	*mock.Call
}

// RegisterHandshake is a helper method to define mock.On call
//   - handshake
func (_e *Network_Expecter) RegisterHandshake(handshake interface{}) *Network_RegisterHandshake_Call {
	return &Network_RegisterHandshake_Call{Call: _e.mock.On("RegisterHandshake", handshake)}
}

func (_c *Network_RegisterHandshake_Call) Run(run func(handshake gen.NetworkHandshake)) *Network_RegisterHandshake_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(gen.NetworkHandshake))
	})
	return _c
}

func (_c *Network_RegisterHandshake_Call) Return() *Network_RegisterHandshake_Call {
	_c.Call.Return()
	return _c
}

func (_c *Network_RegisterHandshake_Call) RunAndReturn(run func(handshake gen.NetworkHandshake)) *Network_RegisterHandshake_Call {
	_c.Run(run)
	return _c
}

// RegisterProto provides a mock function for the type Network
func (_mock *Network) RegisterProto(proto gen.NetworkProto) {
	_mock.Called(proto)
	return
}

// Network_RegisterProto_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RegisterProto'
type Network_RegisterProto_Call struct {
	*mock.Call
}

// RegisterProto is a helper method to define mock.On call
//   - proto
func (_e *Network_Expecter) RegisterProto(proto interface{}) *Network_RegisterProto_Call {
	return &Network_RegisterProto_Call{Call: _e.mock.On("RegisterProto", proto)}
}

func (_c *Network_RegisterProto_Call) Run(run func(proto gen.NetworkProto)) *Network_RegisterProto_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(gen.NetworkProto))
	})
	return _c
}

func (_c *Network_RegisterProto_Call) Return() *Network_RegisterProto_Call {
	_c.Call.Return()
	return _c
}

func (_c *Network_RegisterProto_Call) RunAndReturn(run func(proto gen.NetworkProto)) *Network_RegisterProto_Call {
	_c.Run(run)
	return _c
}

// Registrar provides a mock function for the type Network
func (_mock *Network) Registrar() (gen.Registrar, error) {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Registrar")
	}

	var r0 gen.Registrar
	var r1 error
	if returnFunc, ok := ret.Get(0).(func() (gen.Registrar, error)); ok {
		return returnFunc()
	}
	if returnFunc, ok := ret.Get(0).(func() gen.Registrar); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(gen.Registrar)
		}
	}
	if returnFunc, ok := ret.Get(1).(func() error); ok {
		r1 = returnFunc()
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Network_Registrar_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Registrar'
type Network_Registrar_Call struct {
	*mock.Call
}

// Registrar is a helper method to define mock.On call
func (_e *Network_Expecter) Registrar() *Network_Registrar_Call {
	return &Network_Registrar_Call{Call: _e.mock.On("Registrar")}
}

func (_c *Network_Registrar_Call) Run(run func()) *Network_Registrar_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Network_Registrar_Call) Return(registrar gen.Registrar, err error) *Network_Registrar_Call {
	_c.Call.Return(registrar, err)
	return _c
}

func (_c *Network_Registrar_Call) RunAndReturn(run func() (gen.Registrar, error)) *Network_Registrar_Call {
	_c.Call.Return(run)
	return _c
}

// RemoveProxyRoute provides a mock function for the type Network
func (_mock *Network) RemoveProxyRoute(match string) error {
	ret := _mock.Called(match)

	if len(ret) == 0 {
		panic("no return value specified for RemoveProxyRoute")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(string) error); ok {
		r0 = returnFunc(match)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// Network_RemoveProxyRoute_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RemoveProxyRoute'
type Network_RemoveProxyRoute_Call struct {
	*mock.Call
}

// RemoveProxyRoute is a helper method to define mock.On call
//   - match
func (_e *Network_Expecter) RemoveProxyRoute(match interface{}) *Network_RemoveProxyRoute_Call {
	return &Network_RemoveProxyRoute_Call{Call: _e.mock.On("RemoveProxyRoute", match)}
}

func (_c *Network_RemoveProxyRoute_Call) Run(run func(match string)) *Network_RemoveProxyRoute_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *Network_RemoveProxyRoute_Call) Return(err error) *Network_RemoveProxyRoute_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *Network_RemoveProxyRoute_Call) RunAndReturn(run func(match string) error) *Network_RemoveProxyRoute_Call {
	_c.Call.Return(run)
	return _c
}

// RemoveRoute provides a mock function for the type Network
func (_mock *Network) RemoveRoute(match string) error {
	ret := _mock.Called(match)

	if len(ret) == 0 {
		panic("no return value specified for RemoveRoute")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(string) error); ok {
		r0 = returnFunc(match)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// Network_RemoveRoute_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RemoveRoute'
type Network_RemoveRoute_Call struct {
	*mock.Call
}

// RemoveRoute is a helper method to define mock.On call
//   - match
func (_e *Network_Expecter) RemoveRoute(match interface{}) *Network_RemoveRoute_Call {
	return &Network_RemoveRoute_Call{Call: _e.mock.On("RemoveRoute", match)}
}

func (_c *Network_RemoveRoute_Call) Run(run func(match string)) *Network_RemoveRoute_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *Network_RemoveRoute_Call) Return(err error) *Network_RemoveRoute_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *Network_RemoveRoute_Call) RunAndReturn(run func(match string) error) *Network_RemoveRoute_Call {
	_c.Call.Return(run)
	return _c
}

// Route provides a mock function for the type Network
func (_mock *Network) Route(name gen.Atom) ([]gen.NetworkRoute, error) {
	ret := _mock.Called(name)

	if len(ret) == 0 {
		panic("no return value specified for Route")
	}

	var r0 []gen.NetworkRoute
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(gen.Atom) ([]gen.NetworkRoute, error)); ok {
		return returnFunc(name)
	}
	if returnFunc, ok := ret.Get(0).(func(gen.Atom) []gen.NetworkRoute); ok {
		r0 = returnFunc(name)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]gen.NetworkRoute)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(gen.Atom) error); ok {
		r1 = returnFunc(name)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Network_Route_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Route'
type Network_Route_Call struct {
	*mock.Call
}

// Route is a helper method to define mock.On call
//   - name
func (_e *Network_Expecter) Route(name interface{}) *Network_Route_Call {
	return &Network_Route_Call{Call: _e.mock.On("Route", name)}
}

func (_c *Network_Route_Call) Run(run func(name gen.Atom)) *Network_Route_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(gen.Atom))
	})
	return _c
}

func (_c *Network_Route_Call) Return(networkRoutes []gen.NetworkRoute, err error) *Network_Route_Call {
	_c.Call.Return(networkRoutes, err)
	return _c
}

func (_c *Network_Route_Call) RunAndReturn(run func(name gen.Atom) ([]gen.NetworkRoute, error)) *Network_Route_Call {
	_c.Call.Return(run)
	return _c
}

// SetCookie provides a mock function for the type Network
func (_mock *Network) SetCookie(cookie string) error {
	ret := _mock.Called(cookie)

	if len(ret) == 0 {
		panic("no return value specified for SetCookie")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(string) error); ok {
		r0 = returnFunc(cookie)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// Network_SetCookie_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetCookie'
type Network_SetCookie_Call struct {
	*mock.Call
}

// SetCookie is a helper method to define mock.On call
//   - cookie
func (_e *Network_Expecter) SetCookie(cookie interface{}) *Network_SetCookie_Call {
	return &Network_SetCookie_Call{Call: _e.mock.On("SetCookie", cookie)}
}

func (_c *Network_SetCookie_Call) Run(run func(cookie string)) *Network_SetCookie_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *Network_SetCookie_Call) Return(err error) *Network_SetCookie_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *Network_SetCookie_Call) RunAndReturn(run func(cookie string) error) *Network_SetCookie_Call {
	_c.Call.Return(run)
	return _c
}

// SetMaxMessageSize provides a mock function for the type Network
func (_mock *Network) SetMaxMessageSize(size int) {
	_mock.Called(size)
	return
}

// Network_SetMaxMessageSize_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetMaxMessageSize'
type Network_SetMaxMessageSize_Call struct {
	*mock.Call
}

// SetMaxMessageSize is a helper method to define mock.On call
//   - size
func (_e *Network_Expecter) SetMaxMessageSize(size interface{}) *Network_SetMaxMessageSize_Call {
	return &Network_SetMaxMessageSize_Call{Call: _e.mock.On("SetMaxMessageSize", size)}
}

func (_c *Network_SetMaxMessageSize_Call) Run(run func(size int)) *Network_SetMaxMessageSize_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(int))
	})
	return _c
}

func (_c *Network_SetMaxMessageSize_Call) Return() *Network_SetMaxMessageSize_Call {
	_c.Call.Return()
	return _c
}

func (_c *Network_SetMaxMessageSize_Call) RunAndReturn(run func(size int)) *Network_SetMaxMessageSize_Call {
	_c.Run(run)
	return _c
}

// SetNetworkFlags provides a mock function for the type Network
func (_mock *Network) SetNetworkFlags(flags gen.NetworkFlags) {
	_mock.Called(flags)
	return
}

// Network_SetNetworkFlags_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetNetworkFlags'
type Network_SetNetworkFlags_Call struct {
	*mock.Call
}

// SetNetworkFlags is a helper method to define mock.On call
//   - flags
func (_e *Network_Expecter) SetNetworkFlags(flags interface{}) *Network_SetNetworkFlags_Call {
	return &Network_SetNetworkFlags_Call{Call: _e.mock.On("SetNetworkFlags", flags)}
}

func (_c *Network_SetNetworkFlags_Call) Run(run func(flags gen.NetworkFlags)) *Network_SetNetworkFlags_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(gen.NetworkFlags))
	})
	return _c
}

func (_c *Network_SetNetworkFlags_Call) Return() *Network_SetNetworkFlags_Call {
	_c.Call.Return()
	return _c
}

func (_c *Network_SetNetworkFlags_Call) RunAndReturn(run func(flags gen.NetworkFlags)) *Network_SetNetworkFlags_Call {
	_c.Run(run)
	return _c
}
